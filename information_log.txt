[2025-10-25T01:30:16.090Z] ==== ELECTRON START ====
[2025-10-25T01:30:16.155Z] Electron app ready, starting createWindow()
[2025-10-25T01:30:16.156Z] === STARTING CREATEWINDOW ===
[2025-10-25T01:30:16.156Z] Node.js process: v22.20.0
[2025-10-25T01:30:16.157Z] Electron version: 38.3.0
[2025-10-25T01:30:16.157Z] Current directory: C:\Users\ygaba\source\repos\BPSR-Meter\out\main
[2025-10-25T01:30:16.158Z] Attempting to kill processes on port 8989...
[2025-10-25T01:30:16.228Z] Searching for available port starting from: 8989
[2025-10-25T01:30:16.229Z] Checking port availability: 8989
[2025-10-25T01:30:16.231Z] Port 8989 is available
[2025-10-25T01:30:16.232Z] Available port found: 8989
[2025-10-25T01:30:16.285Z] User data path: C:\Users\ygaba\AppData\Roaming\bpsr-meter
[2025-10-25T01:30:16.286Z] Launching server.js on port 8989 with path: C:\Users\ygaba\source\repos\BPSR-Meter\out\main\server.js
[2025-10-25T01:30:16.624Z] SERVER STDERR: node:electron/js2c/node_init:2
(()=>{"use strict";var t={"./lib/node/asar-fs-wrapper.ts":(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.wrapFsWithAsar=void 0;const s=r("buffer"),n=r("fs"),i=r("path"),a=r("util"),o=process._linkedBinding("electron_common_asar"),c=r("module"),l=global.Promise,f=process.env.ELECTRON_NO_ASAR&&"browser"!==process.type&&"renderer"!==process.type,u=process.internalBinding;delete process.internalBinding;const nextTick=(t,e=[])=>{process.nextTick((()=>t(...e)))},h=u("fs"),p=new Map,getOrCreateArchive=t=>{if(p.has(t))return p.get(t);try{const e=new o.Archive(t);return p.set(t,e),e}catch{return null}};process._getOrCreateArchive=getOrCreateArchive;const d=/\.asar/i,{getValidatedPath:y,getOptions:P,getDirent:_}=require("internal/fs/utils"),{assignFunctionName:A}=require("internal/util"),{validateBoolean:N,validateFunction:F}=require("internal/validators"),{URL:I}=require("internal/url"),splitPath=t=>{if(process.noAsar||f)return{isAsar:!1};let e=t;return s.Buffer.isBuffer(t)&&(e=t.toString()),e instanceof I&&(e=y(e)),"string"!=typeof e?{isAsar:!1}:d.test(e)?o.splitPath(i.normalize(e)):{isAsar:!1}};let v=0;const O=process.getuid?.()??0,g=process.getgid?.()??0,m=new Date;function getDirents(t,{0:e,1:r}){for(let s=0;s<e.length;s++){let n=r[s];const a=splitPath(i.join(t,e[s]));if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)continue;const e=t.stat(a.filePath);if(!e)continue;n=e.type}e[s]=_(t,e[s],n)}return e}var w;!function(t){t[t.kFile=n.constants.UV_DIRENT_FILE]="kFile",t[t.kDirectory=n.constants.UV_DIRENT_DIR]="kDirectory",t[t.kLink=n.constants.UV_DIRENT_LINK]="kLink"}(w||(w={}));const S=new Map([[w.kFile,n.constants.S_IFREG],[w.kDirectory,n.constants.S_IFDIR],[w.kLink,n.constants.S_IFLNK]]),asarStatsToFsStats=function(t){const{Stats:e}=r("fs");return new e(1,n.constants.S_IROTH|n.constants.S_IRGRP|n.constants.S_IRUSR|n.constants.S_IWUSR|S.get(t.type),1,O,g,0,void 0,++v,t.size,void 0,m.getTime(),m.getTime(),m.getTime(),m.getTime())},createError=(t,{asarPath:e,filePath:r}={})=>{let s;switch(t){case"NOT_FOUND":s=new Error(`ENOENT, ${r} not found in ${e}`),s.code="ENOENT",s.errno=-2;break;case"NOT_DIR":s=new Error("ENOTDIR, not a directory"),s.code="ENOTDIR",s.errno=-20;break;case"NO_ACCESS":s=new Error(`EACCES: permission denied, access '${r}'`),s.code="EACCES",s.errno=-13;break;case"INVALID_ARCHIVE":s=new Error(`Invalid package ${e}`);break;default:throw new Error(`Invalid error type "${t}" passed to createError.`)}return s},overrideAPISync=function(t,e,r,s=!1){null==r&&(r=0);const n=t[e],func=function(...t){const e=t[r],s=splitPath(e);if(!s.isAsar)return n.apply(this,t);const{asarPath:i,filePath:a}=s,o=getOrCreateArchive(i);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:i});const c=o.copyFileOut(a);if(!c)throw createError("NOT_FOUND",{asarPath:i,filePath:a});return t[r]=c,n.apply(this,t)};if(s)return func;t[e]=func},overrideAPI=function(t,e,r){null==r&&(r=0);const s=t[e];t[e]=function(...n){const i=n[r],a=splitPath(i);if(!a.isAsar)return s.apply(this,n);const{asarPath:o,filePath:c}=a,l=n[n.length-1];if("function"!=typeof l)return overrideAPISync(t,e,r,!0).apply(this,n);const f=getOrCreateArchive(o);if(!f){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(l,[t])}const u=f.copyFileOut(c);if(u)return n[r]=u,s.apply(this,n);{const t=createError("NOT_FOUND",{asarPath:o,filePath:c});nextTick(l,[t])}},s[a.promisify.custom]&&(t[e][a.promisify.custom]=A(e,makePromiseFunction(s[a.promisify.custom],r))),t.promises&&t.promises[e]&&(t.promises[e]=makePromiseFunction(t.promises[e],r))};let D;function validateBufferIntegrity(t,e){if(!e)return;D=D||r("crypto");const s=D.createHash(e.algorithm).update(t).digest("hex");s!==e.hash&&(console.error(`ASAR Integrity Violation: got a hash mismatch (${s} vs ${e.hash})`),process.exit(1))}const makePromiseFunction=function(t,e){return function(...r){const s=r[e],n=splitPath(s);if(!n.isAsar)return t.apply(this,r);const{asarPath:i,filePath:a}=n,o=getOrCreateArchive(i);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:i}));const c=o.copyFileOut(a);return c?(r[e]=c,t.apply(this,r)):l.reject(createError("NOT_FOUND",{asarPath:i,filePath:a}))}};e.wrapFsWithAsar=t=>{const e=new Map,logASARAccess=(s,n,a)=>{if(process.env.ELECTRON_LOG_ASAR_READS){if(!e.has(s)){const n=`${i.basename(s,".asar")}-access-log.txt`,a=i.join(r("os").tmpdir(),n);e.set(s,t.openSync(a,"a"))}t.writeSync(e.get(s),`${a}: ${n}\n`)}},shouldThrowStatError=t=>!t||"object"!=typeof t||!1!==t.throwIfNoEntry,{lstatSync:n}=t;t.lstatSync=(t,e)=>{const r=splitPath(t);if(!r.isAsar)return n(t,e);const{asarPath:s,filePath:i}=r,a=getOrCreateArchive(s);if(!a){if(shouldThrowStatError(e))throw createError("INVALID_ARCHIVE",{asarPath:s});return null}const o=a.stat(i);if(!o){if(shouldThrowStatError(e))throw createError("NOT_FOUND",{asarPath:s,filePath:i});return null}return asarStatsToFsStats(o)};const{lstat:o}=t;t.lstat=(t,e,r)=>{const s=splitPath(t);if("function"==typeof e&&(r=e,e={}),!s.isAsar)return o(t,e,r);const{asarPath:n,filePath:i}=s,a=getOrCreateArchive(n);if(!a){const t=createError("INVALID_ARCHIVE",{asarPath:n});return void nextTick(r,[t])}const c=a.stat(i);if(!c){const t=createError("NOT_FOUND",{asarPath:n,filePath:i});return void nextTick(r,[t])}const l=asarStatsToFsStats(c);nextTick(r,[null,l])},t.promises.lstat=a.promisify(t.lstat);const{statSync:f}=t;t.statSync=(e,r)=>{const{isAsar:s}=splitPath(e);return s?t.lstatSync(e,r):f(e,r)};const{stat:p}=t;t.stat=(e,r,s)=>{const{isAsar:n}=splitPath(e);if("function"==typeof r&&(s=r,r={}),!n)return p(e,r,s);process.nextTick((()=>t.lstat(e,r,s)))},t.promises.stat=a.promisify(t.stat);const wrapRealpathSync=function(t){return function(e,r){const s=splitPath(e);if(!s.isAsar)return t.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.realpath(a);if(!1===c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});return i.join(t(n,r),c)}},{realpathSync:d}=t;t.realpathSync=wrapRealpathSync(d),t.realpathSync.native=wrapRealpathSync(d.native);const wrapRealpath=function(t){return function(e,r,s){const n=splitPath(e);if(!n.isAsar)return t.apply(this,arguments);const{asarPath:a,filePath:o}=n;arguments.length<3&&(s=r,r={});const c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.realpath(o);if(!1!==l)t(a,r,((t,e)=>{if(null===t){const t=i.join(e,l);s(null,t)}else s(t)}));else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}}},{realpath:I}=t;t.realpath=wrapRealpath(I),t.realpath.native=wrapRealpath(I.native),t.promises.realpath=a.promisify(t.realpath.native);const{exists:v}=t;t.exists=function exists(t,e){let r;try{r=splitPath(t)}catch{return void nextTick(e,[!1])}if(!r.isAsar)return v(t,e);const{asarPath:s,filePath:n}=r,i=getOrCreateArchive(s);if(!i){const t=createError("INVALID_ARCHIVE",{asarPath:s});return void nextTick(e,[t])}const a=!1!==i.stat(n);nextTick(e,[a])},t.exists[a.promisify.custom]=function exists(t){const e=splitPath(t);if(!e.isAsar)return v[a.promisify.custom](t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n){const t=createError("INVALID_ARCHIVE",{asarPath:r});return l.reject(t)}return l.resolve(!1!==n.stat(s))};const{existsSync:O}=t;t.existsSync=t=>{let e;try{e=splitPath(t)}catch{return!1}if(!e.isAsar)return O(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);return!!n&&!1!==n.stat(s)};const{access:g}=t;t.access=function(e,r,s){const n=splitPath(e);if(!n.isAsar)return g.apply(this,arguments);const{asarPath:i,filePath:a}=n;"function"==typeof r&&(s=r,r=t.constants.F_OK);const o=getOrCreateArchive(i);if(!o){const t=createError("INVALID_ARCHIVE",{asarPath:i});return void nextTick(s,[t])}const c=o.getFileInfo(a);if(!c){const t=createError("NOT_FOUND",{asarPath:i,filePath:a});return void nextTick(s,[t])}if(c.unpacked){const e=o.copyFileOut(a);return t.access(e,r,s)}if(o.stat(a))if(r&t.constants.W_OK){const t=createError("NO_ACCESS",{asarPath:i,filePath:a});nextTick(s,[t])}else nextTick(s);else{const t=createError("NOT_FOUND",{asarPath:i,filePath:a});nextTick(s,[t])}};const{access:m}=t.promises;t.promises.access=function(e,r){if(!splitPath(e).isAsar)return m.apply(this,arguments);return a.promisify(t.access)(e,r)};const{accessSync:S}=t;function fsReadFileAsar(e,r,n){const i=splitPath(e);if(i.isAsar){const{asarPath:e,filePath:a}=i;if("function"==typeof r)n=r,r={encoding:null};else if("string"==typeof r)r={encoding:r};else if(null==r)r={encoding:null};else if("object"!=typeof r)throw new TypeError("Bad arguments");const{encoding:o}=r,c=getOrCreateArchive(e);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:e});return void nextTick(n,[t])}const l=c.getFileInfo(a);if(!l){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}if(0===l.size)return void nextTick(n,[null,o?"":s.Buffer.alloc(0)]);if(l.unpacked){const e=c.copyFileOut(a);return t.readFile(e,r,n)}const f=s.Buffer.alloc(l.size),u=c.getFdAndValidateIntegrityLater();if(!(u>=0)){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}logASARAccess(e,a,l.offset),t.read(u,f,0,l.size,l.offset,(t=>{validateBufferIntegrity(f,l.integrity),n(t,o?f.toString(o):f)}))}}t.accessSync=function(e,r){const s=splitPath(e);if(!s.isAsar)return S.apply(this,arguments);const{asarPath:n,filePath:i}=s;null==r&&(r=t.constants.F_OK);const a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(o.unpacked){const e=a.copyFileOut(i);return t.accessSync(e,r)}if(!a.stat(i))throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(r&t.constants.W_OK)throw createError("NO_ACCESS",{asarPath:n,filePath:i})};const{readFile:D}=t;t.readFile=function(t,e,r){return splitPath(t).isAsar?fsReadFileAsar(t,e,r):D.apply(this,arguments)};const{readFile:R}=t.promises;function readFileFromArchiveSync(e,r){const{asarPath:n,filePath:i}=e,a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(0===o.size)return r?"":s.Buffer.alloc(0);if(o.unpacked){const e=a.copyFileOut(i);return t.readFileSync(e,r)}if(r){if("string"==typeof r)r={encoding:r};else if("object"!=typeof r)throw new TypeError("Bad arguments")}else r={encoding:null};const{encoding:c}=r,l=s.Buffer.alloc(o.size),f=a.getFdAndValidateIntegrityLater();if(!(f>=0))throw createError("NOT_FOUND",{asarPath:n,filePath:i});return logASARAccess(n,i,o.offset),t.readSync(f,l,0,o.size,o.offset),validateBufferIntegrity(l,o.integrity),c?l.toString(c):l}t.promises.readFile=function(t,e){if(!splitPath(t).isAsar)return R.apply(this,arguments);return a.promisify(fsReadFileAsar)(t,e)};const{readFileSync:T}=t;t.readFileSync=function(t,e){const r=splitPath(t);return r.isAsar?readFileFromArchiveSync(r,e):T.apply(this,arguments)};const processReaddirResult=t=>t.context.withFileTypes?function handleDirents({result:t,currentPath:e,context:r}){const s=t[0].length;for(let n=0;n<s;n++){const s=i.join(e,t[0][n]),a=splitPath(s);let o=t[1][n];if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)return;const e=t.stat(a.filePath);if(!e)continue;o=e.type}const c=_(e,t[0][n],o),l=u("fs").internalModuleStat(s);r.readdirResults.push(c),(c.isDirectory()||1===l)&&r.pathsQueue.push(i.join(c.path,c.name))}}(t):function handleFilePaths({result:t,currentPath:e,context:r}){for(let s=0;s<t.length;s++){const n=i.join(e,t[s]),a=i.relative(r.basePath,n),o=u("fs").internalModuleStat(n);r.readdirResults.push(a),1===o&&r.pathsQueue.push(n)}}(t);const{readdir:E}=t;t.readdir=function(e,r,s){if(F(s="function"==typeof r?r:s,"callback"),r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return void function readdirRecursive(t,e,r){const s={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};let n=0;!function read(t){const e=new h.FSReqCallback;e.oncomplete=(e,i)=>{e?r(e):void 0!==i?(processReaddirResult({result:i,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)):r(null,s.readdirResults)};const a=splitPath(t);if(a.isAsar){let e;const{asarPath:o,filePath:c}=a,l=getOrCreateArchive(o);if(!l){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(r,[t])}if(e=l.readdir(c),!e){const t=createError("NOT_FOUND",{asarPath:o,filePath:c});return void nextTick(r,[t])}s.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))]),processReaddirResult({result:e,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)}else h.readdir(t,s.encoding,s.withFileTypes,e)}(s.pathsQueue[n++])}(e,r,s);const n=splitPath(e);if(!n.isAsar)return E.apply(this,arguments);const{asarPath:a,filePath:o}=n,c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.readdir(o);if(l)if(r?.withFileTypes){const e=[];for(const r of l){const n=i.join(o,r),l=c.stat(n);if(!l){const t=createError("NOT_FOUND",{asarPath:a,filePath:n});return void nextTick(s,[t])}e.push(new t.Dirent(r,l.type))}nextTick(s,[null,e])}else nextTick(s,[null,l]);else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}};const{readdir:k}=t.promises;t.promises.readdir=async function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return async function readdirRecursivePromises(t,e){const r=[],s=splitPath(t);let n=[];const a=Boolean(e?.withFileTypes);let o=[];if(s.isAsar){const e=getOrCreateArchive(s.asarPath);if(!e)return r;const n=e.readdir(s.filePath);if(!n)return r;o=n,a&&(o=[[...o],o.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else o=await h.readdir(i.toNamespacedPath(t),e.encoding,a,b);if(n=[[t,o]],a)for(;n.length>0;){const{0:t,1:s}=n.pop();for(const a of getDirents(t,s))if(r.push(a),a.isDirectory()){const r=i.join(t,a.name),s=splitPath(r);let o;if(s.isAsar){const t=getOrCreateArchive(s.asarPath);if(!t)continue;const e=t.readdir(s.filePath);if(!e)continue;o=[[...e],e.map((t=>u("fs").internalModuleStat(i.join(r,t))))]}else o=await h.readdir(r,e.encoding,!0,b);n.push([r,o])}}else for(;n.length>0;){const{0:s,1:a}=n.pop();for(const o of a){const a=i.join(s,o),c=u("fs").internalModuleStat(a);if(r.push(i.relative(t,a)),1===c){const t=splitPath(a);let s=[];if(t.isAsar){const e=getOrCreateArchive(t.asarPath);if(!e)return;const n=e.readdir(t.filePath);if(!n)return r;s=n}else s=await h.readdir(i.toNamespacedPath(a),e.encoding,!1,b);n.push([a,s])}}}return r}(e,r);const s=splitPath(e);if(!s.isAsar)return k(e,r);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:n}));const c=o.readdir(a);if(!c)return l.reject(createError("NOT_FOUND",{asarPath:n,filePath:a}));if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return l.resolve(e)}return l.resolve(c)};const{readdirSync:V}=t;t.readdirSync=function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return function readdirSyncRecursive(t,e){const r={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};function read(t){let e;const s=splitPath(t);if(s.isAsar){const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return;if(e=o.readdir(a),!e)return;r.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else e=h.readdir(i.toNamespacedPath(t),r.encoding,r.withFileTypes);void 0!==e&&processReaddirResult({result:e,currentPath:t,context:r})}for(let t=0;t<r.pathsQueue.length;t++)read(r.pathsQueue[t]);return r.readdirResults}(e,r);const s=splitPath(e);if(!s.isAsar)return V.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.readdir(a);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return e}return c};u("modules").overrideReadFileSync((t=>{const e=splitPath(t);if(e.isAsar)try{return readFileFromArchiveSync(e,void 0)}catch{return!1}}));const{internalModuleStat:x}=h;u("fs").internalModuleStat=t=>{const e=splitPath(t);if(!e.isAsar)return x(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n)return-34;const i=n.stat(s);return i?i.type===w.kDirectory?1:0:-34};const{kUsePromises:b}=h;if("win32"===process.platform){const{mkdir:e}=t;t.mkdir=(t,r,s)=>{"function"==typeof r&&(s=r,r={});const n=splitPath(t);if(n.isAsar&&n.filePath.length>0){const t=createError("NOT_DIR");nextTick(s,[t])}else e(t,r,s)},t.promises.mkdir=a.promisify(t.mkdir);const{mkdirSync:r}=t;t.mkdirSync=function(t,e){const s=splitPath(t);if(s.isAsar&&s.filePath.length)throw createError("NOT_DIR");return r(t,e)}}function invokeWithNoAsar(t){return function(){const e=process.noAsar;process.noAsar=!0;try{return t.apply(this,arguments)}finally{process.noAsar=e}}}overrideAPI(t,"copyFile"),overrideAPISync(t,"copyFileSync"),overrideAPI(t,"open"),overrideAPISync(process,"dlopen",1),overrideAPISync(c._extensions,".node",1),overrideAPISync(t,"openSync");const overrideChildProcess=t=>{const{exec:e,execSync:r}=t;t.exec=invokeWithNoAsar(e),t.exec[a.promisify.custom]=A("exec",invokeWithNoAsar(e[a.promisify.custom])),t.execSync=invokeWithNoAsar(r),overrideAPI(t,"execFile"),overrideAPISync(t,"execFileSync")},C=new WeakSet;if(process.env.ELECTRON_EAGER_ASAR_HOOK_FOR_TESTING)overrideChildProcess(r("child_process"));else{const t=c._load;c._load=(e,...r)=>{const s=t(e,...r);if(("child_process"===e||"node:child_process"===e)&&!C.has(s)){C.add(s);overrideChildProcess(s)}return s}}}},buffer:t=>{t.exports=require("buffer")},child_process:t=>{t.exports=require("child_process")},crypto:t=>{t.exports=require("crypto")},fs:t=>{t.exports=require("fs")},module:t=>{t.exports=require("module")},os:t=>{t.exports=require("os")},path:t=>{t.exports=require("path")},util:t=>{t.exports=require("util")}},e={};function __webpack_require__(r){var s=e[r];if(void 0!==s)return s.exports;var n=e[r]={exports:{}};return t[r](n,n.exports,__webpack_require__),n.exports}var r={};(()=>{var t=r;Object.defineProperty(t,"__esModule",{value:!0});if((0,__webpack_require__("./lib/node/asar-fs-wrapper.ts").wrapFsWithAsar)(__webpack_require__("fs")),globalThis.blinkfetch){const t=["fetch","Response","FormData","Request","Headers","EventSource"];for(const e of t)globalThis[e]=globalThis[`blink${e}`]}const e=__webpack_require__("child_process"),s=e.fork;e.fork=(t,e,r)=>(null==e?e=[]:"object"!=typeof e||Array.isArray(e)||(r=e,e=[]),"string"!=typeof t||!Array.isArray(e)||"object"!=typeof r&&void 0!==r||((r=r??{}).env=Object.create(r.env||process.env),r.env.ELECTRON_RUN_AS_NODE="1",r.execPath||"darwin"!==process.platform||(r.execPath=process.helperExecPath)),s(t,e,r));const n=__webpack_require__("path"),i=__webpack_require__("module"),a=process.resourcesPath+n.sep,o=i._nodeModulePaths;i._nodeModulePaths=function(t){const e=o(t);return(n.resolve(t)+n.sep).startsWith(a)?e.filter((function(t){return t.startsWith(a)})):e}})()})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

Error: The specified module could not be found.
C:\Users\ygaba\source\repos\BPSR-Meter\node_modules\electron\dist\resources\build\Release\windivert.node
    at process.func [as dlopen] (node:electron/js2c/node_init:2:2617)
    at file:///C:/Users/ygaba/source/repos/BPSR-Meter/out/main/server.js:735:9
    at ModuleJob.run (node:internal/modules/esm/module_job:345:25)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:665:26)
    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:132:5) {
  code: 'ERR_DLOPEN_FAILED'
}
[2025-10-25T01:30:16.625Z] SERVER STDERR: Node.js v22.20.0
[2025-10-25T01:30:16.634Z] SERVER PROCESS EXITED with code: 1, signal: null
[2025-10-25T01:30:16.635Z] SERVER PROCESS CLOSED with code: 1
[2025-10-25T01:30:26.305Z] ERROR: Server did not respond in time (10s timeout)
[2025-10-25T01:30:40.880Z] All windows closed
[2025-10-25T01:30:40.881Z] Closing application (not macOS)
[2025-10-25T01:30:40.881Z] App closing, cleaning up processes...
[2025-10-25T01:32:54.422Z] ==== ELECTRON START ====
[2025-10-25T01:32:54.495Z] Electron app ready, starting createWindow()
[2025-10-25T01:32:54.496Z] === STARTING CREATEWINDOW ===
[2025-10-25T01:32:54.497Z] Node.js process: v22.20.0
[2025-10-25T01:32:54.498Z] Electron version: 38.3.0
[2025-10-25T01:32:54.498Z] Current directory: C:\Users\ygaba\source\repos\BPSR-Meter\out\main
[2025-10-25T01:32:54.499Z] Attempting to kill processes on port 8989...
[2025-10-25T01:32:54.560Z] Searching for available port starting from: 8989
[2025-10-25T01:32:54.560Z] Checking port availability: 8989
[2025-10-25T01:32:54.563Z] Port 8989 is available
[2025-10-25T01:32:54.563Z] Available port found: 8989
[2025-10-25T01:32:54.623Z] User data path: C:\Users\ygaba\AppData\Roaming\bpsr-meter
[2025-10-25T01:32:54.623Z] Launching server.js on port 8989 with path: C:\Users\ygaba\source\repos\BPSR-Meter\out\main\server.js
[2025-10-25T01:32:54.942Z] SERVER STDERR: node:electron/js2c/node_init:2
(()=>{"use strict";var t={"./lib/node/asar-fs-wrapper.ts":(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.wrapFsWithAsar=void 0;const s=r("buffer"),n=r("fs"),i=r("path"),a=r("util"),o=process._linkedBinding("electron_common_asar"),c=r("module"),l=global.Promise,f=process.env.ELECTRON_NO_ASAR&&"browser"!==process.type&&"renderer"!==process.type,u=process.internalBinding;delete process.internalBinding;const nextTick=(t,e=[])=>{process.nextTick((()=>t(...e)))},h=u("fs"),p=new Map,getOrCreateArchive=t=>{if(p.has(t))return p.get(t);try{const e=new o.Archive(t);return p.set(t,e),e}catch{return null}};process._getOrCreateArchive=getOrCreateArchive;const d=/\.asar/i,{getValidatedPath:y,getOptions:P,getDirent:_}=require("internal/fs/utils"),{assignFunctionName:A}=require("internal/util"),{validateBoolean:N,validateFunction:F}=require("internal/validators"),{URL:I}=require("internal/url"),splitPath=t=>{if(process.noAsar||f)return{isAsar:!1};let e=t;return s.Buffer.isBuffer(t)&&(e=t.toString()),e instanceof I&&(e=y(e)),"string"!=typeof e?{isAsar:!1}:d.test(e)?o.splitPath(i.normalize(e)):{isAsar:!1}};let v=0;const O=process.getuid?.()??0,g=process.getgid?.()??0,m=new Date;function getDirents(t,{0:e,1:r}){for(let s=0;s<e.length;s++){let n=r[s];const a=splitPath(i.join(t,e[s]));if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)continue;const e=t.stat(a.filePath);if(!e)continue;n=e.type}e[s]=_(t,e[s],n)}return e}var w;!function(t){t[t.kFile=n.constants.UV_DIRENT_FILE]="kFile",t[t.kDirectory=n.constants.UV_DIRENT_DIR]="kDirectory",t[t.kLink=n.constants.UV_DIRENT_LINK]="kLink"}(w||(w={}));const S=new Map([[w.kFile,n.constants.S_IFREG],[w.kDirectory,n.constants.S_IFDIR],[w.kLink,n.constants.S_IFLNK]]),asarStatsToFsStats=function(t){const{Stats:e}=r("fs");return new e(1,n.constants.S_IROTH|n.constants.S_IRGRP|n.constants.S_IRUSR|n.constants.S_IWUSR|S.get(t.type),1,O,g,0,void 0,++v,t.size,void 0,m.getTime(),m.getTime(),m.getTime(),m.getTime())},createError=(t,{asarPath:e,filePath:r}={})=>{let s;switch(t){case"NOT_FOUND":s=new Error(`ENOENT, ${r} not found in ${e}`),s.code="ENOENT",s.errno=-2;break;case"NOT_DIR":s=new Error("ENOTDIR, not a directory"),s.code="ENOTDIR",s.errno=-20;break;case"NO_ACCESS":s=new Error(`EACCES: permission denied, access '${r}'`),s.code="EACCES",s.errno=-13;break;case"INVALID_ARCHIVE":s=new Error(`Invalid package ${e}`);break;default:throw new Error(`Invalid error type "${t}" passed to createError.`)}return s},overrideAPISync=function(t,e,r,s=!1){null==r&&(r=0);const n=t[e],func=function(...t){const e=t[r],s=splitPath(e);if(!s.isAsar)return n.apply(this,t);const{asarPath:i,filePath:a}=s,o=getOrCreateArchive(i);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:i});const c=o.copyFileOut(a);if(!c)throw createError("NOT_FOUND",{asarPath:i,filePath:a});return t[r]=c,n.apply(this,t)};if(s)return func;t[e]=func},overrideAPI=function(t,e,r){null==r&&(r=0);const s=t[e];t[e]=function(...n){const i=n[r],a=splitPath(i);if(!a.isAsar)return s.apply(this,n);const{asarPath:o,filePath:c}=a,l=n[n.length-1];if("function"!=typeof l)return overrideAPISync(t,e,r,!0).apply(this,n);const f=getOrCreateArchive(o);if(!f){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(l,[t])}const u=f.copyFileOut(c);if(u)return n[r]=u,s.apply(this,n);{const t=createError("NOT_FOUND",{asarPath:o,filePath:c});nextTick(l,[t])}},s[a.promisify.custom]&&(t[e][a.promisify.custom]=A(e,makePromiseFunction(s[a.promisify.custom],r))),t.promises&&t.promises[e]&&(t.promises[e]=makePromiseFunction(t.promises[e],r))};let D;function validateBufferIntegrity(t,e){if(!e)return;D=D||r("crypto");const s=D.createHash(e.algorithm).update(t).digest("hex");s!==e.hash&&(console.error(`ASAR Integrity Violation: got a hash mismatch (${s} vs ${e.hash})`),process.exit(1))}const makePromiseFunction=function(t,e){return function(...r){const s=r[e],n=splitPath(s);if(!n.isAsar)return t.apply(this,r);const{asarPath:i,filePath:a}=n,o=getOrCreateArchive(i);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:i}));const c=o.copyFileOut(a);return c?(r[e]=c,t.apply(this,r)):l.reject(createError("NOT_FOUND",{asarPath:i,filePath:a}))}};e.wrapFsWithAsar=t=>{const e=new Map,logASARAccess=(s,n,a)=>{if(process.env.ELECTRON_LOG_ASAR_READS){if(!e.has(s)){const n=`${i.basename(s,".asar")}-access-log.txt`,a=i.join(r("os").tmpdir(),n);e.set(s,t.openSync(a,"a"))}t.writeSync(e.get(s),`${a}: ${n}\n`)}},shouldThrowStatError=t=>!t||"object"!=typeof t||!1!==t.throwIfNoEntry,{lstatSync:n}=t;t.lstatSync=(t,e)=>{const r=splitPath(t);if(!r.isAsar)return n(t,e);const{asarPath:s,filePath:i}=r,a=getOrCreateArchive(s);if(!a){if(shouldThrowStatError(e))throw createError("INVALID_ARCHIVE",{asarPath:s});return null}const o=a.stat(i);if(!o){if(shouldThrowStatError(e))throw createError("NOT_FOUND",{asarPath:s,filePath:i});return null}return asarStatsToFsStats(o)};const{lstat:o}=t;t.lstat=(t,e,r)=>{const s=splitPath(t);if("function"==typeof e&&(r=e,e={}),!s.isAsar)return o(t,e,r);const{asarPath:n,filePath:i}=s,a=getOrCreateArchive(n);if(!a){const t=createError("INVALID_ARCHIVE",{asarPath:n});return void nextTick(r,[t])}const c=a.stat(i);if(!c){const t=createError("NOT_FOUND",{asarPath:n,filePath:i});return void nextTick(r,[t])}const l=asarStatsToFsStats(c);nextTick(r,[null,l])},t.promises.lstat=a.promisify(t.lstat);const{statSync:f}=t;t.statSync=(e,r)=>{const{isAsar:s}=splitPath(e);return s?t.lstatSync(e,r):f(e,r)};const{stat:p}=t;t.stat=(e,r,s)=>{const{isAsar:n}=splitPath(e);if("function"==typeof r&&(s=r,r={}),!n)return p(e,r,s);process.nextTick((()=>t.lstat(e,r,s)))},t.promises.stat=a.promisify(t.stat);const wrapRealpathSync=function(t){return function(e,r){const s=splitPath(e);if(!s.isAsar)return t.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.realpath(a);if(!1===c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});return i.join(t(n,r),c)}},{realpathSync:d}=t;t.realpathSync=wrapRealpathSync(d),t.realpathSync.native=wrapRealpathSync(d.native);const wrapRealpath=function(t){return function(e,r,s){const n=splitPath(e);if(!n.isAsar)return t.apply(this,arguments);const{asarPath:a,filePath:o}=n;arguments.length<3&&(s=r,r={});const c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.realpath(o);if(!1!==l)t(a,r,((t,e)=>{if(null===t){const t=i.join(e,l);s(null,t)}else s(t)}));else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}}},{realpath:I}=t;t.realpath=wrapRealpath(I),t.realpath.native=wrapRealpath(I.native),t.promises.realpath=a.promisify(t.realpath.native);const{exists:v}=t;t.exists=function exists(t,e){let r;try{r=splitPath(t)}catch{return void nextTick(e,[!1])}if(!r.isAsar)return v(t,e);const{asarPath:s,filePath:n}=r,i=getOrCreateArchive(s);if(!i){const t=createError("INVALID_ARCHIVE",{asarPath:s});return void nextTick(e,[t])}const a=!1!==i.stat(n);nextTick(e,[a])},t.exists[a.promisify.custom]=function exists(t){const e=splitPath(t);if(!e.isAsar)return v[a.promisify.custom](t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n){const t=createError("INVALID_ARCHIVE",{asarPath:r});return l.reject(t)}return l.resolve(!1!==n.stat(s))};const{existsSync:O}=t;t.existsSync=t=>{let e;try{e=splitPath(t)}catch{return!1}if(!e.isAsar)return O(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);return!!n&&!1!==n.stat(s)};const{access:g}=t;t.access=function(e,r,s){const n=splitPath(e);if(!n.isAsar)return g.apply(this,arguments);const{asarPath:i,filePath:a}=n;"function"==typeof r&&(s=r,r=t.constants.F_OK);const o=getOrCreateArchive(i);if(!o){const t=createError("INVALID_ARCHIVE",{asarPath:i});return void nextTick(s,[t])}const c=o.getFileInfo(a);if(!c){const t=createError("NOT_FOUND",{asarPath:i,filePath:a});return void nextTick(s,[t])}if(c.unpacked){const e=o.copyFileOut(a);return t.access(e,r,s)}if(o.stat(a))if(r&t.constants.W_OK){const t=createError("NO_ACCESS",{asarPath:i,filePath:a});nextTick(s,[t])}else nextTick(s);else{const t=createError("NOT_FOUND",{asarPath:i,filePath:a});nextTick(s,[t])}};const{access:m}=t.promises;t.promises.access=function(e,r){if(!splitPath(e).isAsar)return m.apply(this,arguments);return a.promisify(t.access)(e,r)};const{accessSync:S}=t;function fsReadFileAsar(e,r,n){const i=splitPath(e);if(i.isAsar){const{asarPath:e,filePath:a}=i;if("function"==typeof r)n=r,r={encoding:null};else if("string"==typeof r)r={encoding:r};else if(null==r)r={encoding:null};else if("object"!=typeof r)throw new TypeError("Bad arguments");const{encoding:o}=r,c=getOrCreateArchive(e);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:e});return void nextTick(n,[t])}const l=c.getFileInfo(a);if(!l){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}if(0===l.size)return void nextTick(n,[null,o?"":s.Buffer.alloc(0)]);if(l.unpacked){const e=c.copyFileOut(a);return t.readFile(e,r,n)}const f=s.Buffer.alloc(l.size),u=c.getFdAndValidateIntegrityLater();if(!(u>=0)){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}logASARAccess(e,a,l.offset),t.read(u,f,0,l.size,l.offset,(t=>{validateBufferIntegrity(f,l.integrity),n(t,o?f.toString(o):f)}))}}t.accessSync=function(e,r){const s=splitPath(e);if(!s.isAsar)return S.apply(this,arguments);const{asarPath:n,filePath:i}=s;null==r&&(r=t.constants.F_OK);const a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(o.unpacked){const e=a.copyFileOut(i);return t.accessSync(e,r)}if(!a.stat(i))throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(r&t.constants.W_OK)throw createError("NO_ACCESS",{asarPath:n,filePath:i})};const{readFile:D}=t;t.readFile=function(t,e,r){return splitPath(t).isAsar?fsReadFileAsar(t,e,r):D.apply(this,arguments)};const{readFile:R}=t.promises;function readFileFromArchiveSync(e,r){const{asarPath:n,filePath:i}=e,a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(0===o.size)return r?"":s.Buffer.alloc(0);if(o.unpacked){const e=a.copyFileOut(i);return t.readFileSync(e,r)}if(r){if("string"==typeof r)r={encoding:r};else if("object"!=typeof r)throw new TypeError("Bad arguments")}else r={encoding:null};const{encoding:c}=r,l=s.Buffer.alloc(o.size),f=a.getFdAndValidateIntegrityLater();if(!(f>=0))throw createError("NOT_FOUND",{asarPath:n,filePath:i});return logASARAccess(n,i,o.offset),t.readSync(f,l,0,o.size,o.offset),validateBufferIntegrity(l,o.integrity),c?l.toString(c):l}t.promises.readFile=function(t,e){if(!splitPath(t).isAsar)return R.apply(this,arguments);return a.promisify(fsReadFileAsar)(t,e)};const{readFileSync:T}=t;t.readFileSync=function(t,e){const r=splitPath(t);return r.isAsar?readFileFromArchiveSync(r,e):T.apply(this,arguments)};const processReaddirResult=t=>t.context.withFileTypes?function handleDirents({result:t,currentPath:e,context:r}){const s=t[0].length;for(let n=0;n<s;n++){const s=i.join(e,t[0][n]),a=splitPath(s);let o=t[1][n];if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)return;const e=t.stat(a.filePath);if(!e)continue;o=e.type}const c=_(e,t[0][n],o),l=u("fs").internalModuleStat(s);r.readdirResults.push(c),(c.isDirectory()||1===l)&&r.pathsQueue.push(i.join(c.path,c.name))}}(t):function handleFilePaths({result:t,currentPath:e,context:r}){for(let s=0;s<t.length;s++){const n=i.join(e,t[s]),a=i.relative(r.basePath,n),o=u("fs").internalModuleStat(n);r.readdirResults.push(a),1===o&&r.pathsQueue.push(n)}}(t);const{readdir:E}=t;t.readdir=function(e,r,s){if(F(s="function"==typeof r?r:s,"callback"),r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return void function readdirRecursive(t,e,r){const s={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};let n=0;!function read(t){const e=new h.FSReqCallback;e.oncomplete=(e,i)=>{e?r(e):void 0!==i?(processReaddirResult({result:i,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)):r(null,s.readdirResults)};const a=splitPath(t);if(a.isAsar){let e;const{asarPath:o,filePath:c}=a,l=getOrCreateArchive(o);if(!l){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(r,[t])}if(e=l.readdir(c),!e){const t=createError("NOT_FOUND",{asarPath:o,filePath:c});return void nextTick(r,[t])}s.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))]),processReaddirResult({result:e,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)}else h.readdir(t,s.encoding,s.withFileTypes,e)}(s.pathsQueue[n++])}(e,r,s);const n=splitPath(e);if(!n.isAsar)return E.apply(this,arguments);const{asarPath:a,filePath:o}=n,c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.readdir(o);if(l)if(r?.withFileTypes){const e=[];for(const r of l){const n=i.join(o,r),l=c.stat(n);if(!l){const t=createError("NOT_FOUND",{asarPath:a,filePath:n});return void nextTick(s,[t])}e.push(new t.Dirent(r,l.type))}nextTick(s,[null,e])}else nextTick(s,[null,l]);else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}};const{readdir:k}=t.promises;t.promises.readdir=async function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return async function readdirRecursivePromises(t,e){const r=[],s=splitPath(t);let n=[];const a=Boolean(e?.withFileTypes);let o=[];if(s.isAsar){const e=getOrCreateArchive(s.asarPath);if(!e)return r;const n=e.readdir(s.filePath);if(!n)return r;o=n,a&&(o=[[...o],o.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else o=await h.readdir(i.toNamespacedPath(t),e.encoding,a,b);if(n=[[t,o]],a)for(;n.length>0;){const{0:t,1:s}=n.pop();for(const a of getDirents(t,s))if(r.push(a),a.isDirectory()){const r=i.join(t,a.name),s=splitPath(r);let o;if(s.isAsar){const t=getOrCreateArchive(s.asarPath);if(!t)continue;const e=t.readdir(s.filePath);if(!e)continue;o=[[...e],e.map((t=>u("fs").internalModuleStat(i.join(r,t))))]}else o=await h.readdir(r,e.encoding,!0,b);n.push([r,o])}}else for(;n.length>0;){const{0:s,1:a}=n.pop();for(const o of a){const a=i.join(s,o),c=u("fs").internalModuleStat(a);if(r.push(i.relative(t,a)),1===c){const t=splitPath(a);let s=[];if(t.isAsar){const e=getOrCreateArchive(t.asarPath);if(!e)return;const n=e.readdir(t.filePath);if(!n)return r;s=n}else s=await h.readdir(i.toNamespacedPath(a),e.encoding,!1,b);n.push([a,s])}}}return r}(e,r);const s=splitPath(e);if(!s.isAsar)return k(e,r);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:n}));const c=o.readdir(a);if(!c)return l.reject(createError("NOT_FOUND",{asarPath:n,filePath:a}));if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return l.resolve(e)}return l.resolve(c)};const{readdirSync:V}=t;t.readdirSync=function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return function readdirSyncRecursive(t,e){const r={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};function read(t){let e;const s=splitPath(t);if(s.isAsar){const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return;if(e=o.readdir(a),!e)return;r.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else e=h.readdir(i.toNamespacedPath(t),r.encoding,r.withFileTypes);void 0!==e&&processReaddirResult({result:e,currentPath:t,context:r})}for(let t=0;t<r.pathsQueue.length;t++)read(r.pathsQueue[t]);return r.readdirResults}(e,r);const s=splitPath(e);if(!s.isAsar)return V.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.readdir(a);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return e}return c};u("modules").overrideReadFileSync((t=>{const e=splitPath(t);if(e.isAsar)try{return readFileFromArchiveSync(e,void 0)}catch{return!1}}));const{internalModuleStat:x}=h;u("fs").internalModuleStat=t=>{const e=splitPath(t);if(!e.isAsar)return x(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n)return-34;const i=n.stat(s);return i?i.type===w.kDirectory?1:0:-34};const{kUsePromises:b}=h;if("win32"===process.platform){const{mkdir:e}=t;t.mkdir=(t,r,s)=>{"function"==typeof r&&(s=r,r={});const n=splitPath(t);if(n.isAsar&&n.filePath.length>0){const t=createError("NOT_DIR");nextTick(s,[t])}else e(t,r,s)},t.promises.mkdir=a.promisify(t.mkdir);const{mkdirSync:r}=t;t.mkdirSync=function(t,e){const s=splitPath(t);if(s.isAsar&&s.filePath.length)throw createError("NOT_DIR");return r(t,e)}}function invokeWithNoAsar(t){return function(){const e=process.noAsar;process.noAsar=!0;try{return t.apply(this,arguments)}finally{process.noAsar=e}}}overrideAPI(t,"copyFile"),overrideAPISync(t,"copyFileSync"),overrideAPI(t,"open"),overrideAPISync(process,"dlopen",1),overrideAPISync(c._extensions,".node",1),overrideAPISync(t,"openSync");const overrideChildProcess=t=>{const{exec:e,execSync:r}=t;t.exec=invokeWithNoAsar(e),t.exec[a.promisify.custom]=A("exec",invokeWithNoAsar(e[a.promisify.custom])),t.execSync=invokeWithNoAsar(r),overrideAPI(t,"execFile"),overrideAPISync(t,"execFileSync")},C=new WeakSet;if(process.env.ELECTRON_EAGER_ASAR_HOOK_FOR_TESTING)overrideChildProcess(r("child_process"));else{const t=c._load;c._load=(e,...r)=>{const s=t(e,...r);if(("child_process"===e||"node:child_process"===e)&&!C.has(s)){C.add(s);overrideChildProcess(s)}return s}}}},buffer:t=>{t.exports=require("buffer")},child_process:t=>{t.exports=require("child_process")},crypto:t=>{t.exports=require("crypto")},fs:t=>{t.exports=require("fs")},module:t=>{t.exports=require("module")},os:t=>{t.exports=require("os")},path:t=>{t.exports=require("path")},util:t=>{t.exports=require("util")}},e={};function __webpack_require__(r){var s=e[r];if(void 0!==s)return s.exports;var n=e[r]={exports:{}};return t[r](n,n.exports,__webpack_require__),n.exports}var r={};(()=>{var t=r;Object.defineProperty(t,"__esModule",{value:!0});if((0,__webpack_require__("./lib/node/asar-fs-wrapper.ts").wrapFsWithAsar)(__webpack_require__("fs")),globalThis.blinkfetch){const t=["fetch","Response","FormData","Request","Headers","EventSource"];for(const e of t)globalThis[e]=globalThis[`blink${e}`]}const e=__webpack_require__("child_process"),s=e.fork;e.fork=(t,e,r)=>(null==e?e=[]:"object"!=typeof e||Array.isArray(e)||(r=e,e=[]),"string"!=typeof t||!Array.isArray(e)||"object"!=typeof r&&void 0!==r||((r=r??{}).env=Object.create(r.env||process.env),r.env.ELECTRON_RUN_AS_NODE="1",r.execPath||"darwin"!==process.platform||(r.execPath=process.helperExecPath)),s(t,e,r));const n=__webpack_require__("path"),i=__webpack_require__("module"),a=process.resourcesPath+n.sep,o=i._nodeModulePaths;i._nodeModulePaths=function(t){const e=o(t);return(n.resolve(t)+n.sep).startsWith(a)?e.filter((function(t){return t.startsWith(a)})):e}})()})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

Error: The specified module could not be found.
C:\Users\ygaba\source\repos\BPSR-Meter\node_modules\electron\dist\resources\build\Release\windivert.node
    at process.func [as dlopen] (node:electron/js2c/node_init:2:2617)
    at file:///C:/Users/ygaba/source/repos/BPSR-Meter/out/main/server.js:735:9
    at ModuleJob.run (node:internal/modules/esm/module_job:345:25)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:665:26)
    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:132:5) {
  code: 'ERR_DLOPEN_FAILED'
}

Node.js v22.20.0
[2025-10-25T01:32:54.957Z] SERVER PROCESS EXITED with code: 1, signal: null
[2025-10-25T01:32:54.957Z] SERVER PROCESS CLOSED with code: 1
[2025-10-25T01:33:04.633Z] ERROR: Server did not respond in time (10s timeout)
[2025-10-25T01:33:05.860Z] All windows closed
[2025-10-25T01:33:05.861Z] Closing application (not macOS)
[2025-10-25T01:33:05.862Z] App closing, cleaning up processes...
[2025-10-25T01:34:46.541Z] ==== ELECTRON START ====
[2025-10-25T01:34:46.604Z] Electron app ready, starting createWindow()
[2025-10-25T01:34:46.605Z] === STARTING CREATEWINDOW ===
[2025-10-25T01:34:46.605Z] Node.js process: v22.20.0
[2025-10-25T01:34:46.606Z] Electron version: 38.3.0
[2025-10-25T01:34:46.606Z] Current directory: C:\Users\ygaba\source\repos\BPSR-Meter\out\main
[2025-10-25T01:34:46.607Z] Attempting to kill processes on port 8989...
[2025-10-25T01:34:46.660Z] Searching for available port starting from: 8989
[2025-10-25T01:34:46.661Z] Checking port availability: 8989
[2025-10-25T01:34:46.664Z] Port 8989 is available
[2025-10-25T01:34:46.664Z] Available port found: 8989
[2025-10-25T01:34:46.723Z] User data path: C:\Users\ygaba\AppData\Roaming\bpsr-meter
[2025-10-25T01:34:46.724Z] Launching server.js on port 8989 with path: C:\Users\ygaba\source\repos\BPSR-Meter\out\main\server.js
[2025-10-25T01:34:47.076Z] SERVER STDERR: node:electron/js2c/node_init:2
(()=>{"use strict";var t={"./lib/node/asar-fs-wrapper.ts":(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.wrapFsWithAsar=void 0;const s=r("buffer"),n=r("fs"),i=r("path"),a=r("util"),o=process._linkedBinding("electron_common_asar"),c=r("module"),l=global.Promise,f=process.env.ELECTRON_NO_ASAR&&"browser"!==process.type&&"renderer"!==process.type,u=process.internalBinding;delete process.internalBinding;const nextTick=(t,e=[])=>{process.nextTick((()=>t(...e)))},h=u("fs"),p=new Map,getOrCreateArchive=t=>{if(p.has(t))return p.get(t);try{const e=new o.Archive(t);return p.set(t,e),e}catch{return null}};process._getOrCreateArchive=getOrCreateArchive;const d=/\.asar/i,{getValidatedPath:y,getOptions:P,getDirent:_}=require("internal/fs/utils"),{assignFunctionName:A}=require("internal/util"),{validateBoolean:N,validateFunction:F}=require("internal/validators"),{URL:I}=require("internal/url"),splitPath=t=>{if(process.noAsar||f)return{isAsar:!1};let e=t;return s.Buffer.isBuffer(t)&&(e=t.toString()),e instanceof I&&(e=y(e)),"string"!=typeof e?{isAsar:!1}:d.test(e)?o.splitPath(i.normalize(e)):{isAsar:!1}};let v=0;const O=process.getuid?.()??0,g=process.getgid?.()??0,m=new Date;function getDirents(t,{0:e,1:r}){for(let s=0;s<e.length;s++){let n=r[s];const a=splitPath(i.join(t,e[s]));if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)continue;const e=t.stat(a.filePath);if(!e)continue;n=e.type}e[s]=_(t,e[s],n)}return e}var w;!function(t){t[t.kFile=n.constants.UV_DIRENT_FILE]="kFile",t[t.kDirectory=n.constants.UV_DIRENT_DIR]="kDirectory",t[t.kLink=n.constants.UV_DIRENT_LINK]="kLink"}(w||(w={}));const S=new Map([[w.kFile,n.constants.S_IFREG],[w.kDirectory,n.constants.S_IFDIR],[w.kLink,n.constants.S_IFLNK]]),asarStatsToFsStats=function(t){const{Stats:e}=r("fs");return new e(1,n.constants.S_IROTH|n.constants.S_IRGRP|n.constants.S_IRUSR|n.constants.S_IWUSR|S.get(t.type),1,O,g,0,void 0,++v,t.size,void 0,m.getTime(),m.getTime(),m.getTime(),m.getTime())},createError=(t,{asarPath:e,filePath:r}={})=>{let s;switch(t){case"NOT_FOUND":s=new Error(`ENOENT, ${r} not found in ${e}`),s.code="ENOENT",s.errno=-2;break;case"NOT_DIR":s=new Error("ENOTDIR, not a directory"),s.code="ENOTDIR",s.errno=-20;break;case"NO_ACCESS":s=new Error(`EACCES: permission denied, access '${r}'`),s.code="EACCES",s.errno=-13;break;case"INVALID_ARCHIVE":s=new Error(`Invalid package ${e}`);break;default:throw new Error(`Invalid error type "${t}" passed to createError.`)}return s},overrideAPISync=function(t,e,r,s=!1){null==r&&(r=0);const n=t[e],func=function(...t){const e=t[r],s=splitPath(e);if(!s.isAsar)return n.apply(this,t);const{asarPath:i,filePath:a}=s,o=getOrCreateArchive(i);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:i});const c=o.copyFileOut(a);if(!c)throw createError("NOT_FOUND",{asarPath:i,filePath:a});return t[r]=c,n.apply(this,t)};if(s)return func;t[e]=func},overrideAPI=function(t,e,r){null==r&&(r=0);const s=t[e];t[e]=function(...n){const i=n[r],a=splitPath(i);if(!a.isAsar)return s.apply(this,n);const{asarPath:o,filePath:c}=a,l=n[n.length-1];if("function"!=typeof l)return overrideAPISync(t,e,r,!0).apply(this,n);const f=getOrCreateArchive(o);if(!f){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(l,[t])}const u=f.copyFileOut(c);if(u)return n[r]=u,s.apply(this,n);{const t=createError("NOT_FOUND",{asarPath:o,filePath:c});nextTick(l,[t])}},s[a.promisify.custom]&&(t[e][a.promisify.custom]=A(e,makePromiseFunction(s[a.promisify.custom],r))),t.promises&&t.promises[e]&&(t.promises[e]=makePromiseFunction(t.promises[e],r))};let D;function validateBufferIntegrity(t,e){if(!e)return;D=D||r("crypto");const s=D.createHash(e.algorithm).update(t).digest("hex");s!==e.hash&&(console.error(`ASAR Integrity Violation: got a hash mismatch (${s} vs ${e.hash})`),process.exit(1))}const makePromiseFunction=function(t,e){return function(...r){const s=r[e],n=splitPath(s);if(!n.isAsar)return t.apply(this,r);const{asarPath:i,filePath:a}=n,o=getOrCreateArchive(i);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:i}));const c=o.copyFileOut(a);return c?(r[e]=c,t.apply(this,r)):l.reject(createError("NOT_FOUND",{asarPath:i,filePath:a}))}};e.wrapFsWithAsar=t=>{const e=new Map,logASARAccess=(s,n,a)=>{if(process.env.ELECTRON_LOG_ASAR_READS){if(!e.has(s)){const n=`${i.basename(s,".asar")}-access-log.txt`,a=i.join(r("os").tmpdir(),n);e.set(s,t.openSync(a,"a"))}t.writeSync(e.get(s),`${a}: ${n}\n`)}},shouldThrowStatError=t=>!t||"object"!=typeof t||!1!==t.throwIfNoEntry,{lstatSync:n}=t;t.lstatSync=(t,e)=>{const r=splitPath(t);if(!r.isAsar)return n(t,e);const{asarPath:s,filePath:i}=r,a=getOrCreateArchive(s);if(!a){if(shouldThrowStatError(e))throw createError("INVALID_ARCHIVE",{asarPath:s});return null}const o=a.stat(i);if(!o){if(shouldThrowStatError(e))throw createError("NOT_FOUND",{asarPath:s,filePath:i});return null}return asarStatsToFsStats(o)};const{lstat:o}=t;t.lstat=(t,e,r)=>{const s=splitPath(t);if("function"==typeof e&&(r=e,e={}),!s.isAsar)return o(t,e,r);const{asarPath:n,filePath:i}=s,a=getOrCreateArchive(n);if(!a){const t=createError("INVALID_ARCHIVE",{asarPath:n});return void nextTick(r,[t])}const c=a.stat(i);if(!c){const t=createError("NOT_FOUND",{asarPath:n,filePath:i});return void nextTick(r,[t])}const l=asarStatsToFsStats(c);nextTick(r,[null,l])},t.promises.lstat=a.promisify(t.lstat);const{statSync:f}=t;t.statSync=(e,r)=>{const{isAsar:s}=splitPath(e);return s?t.lstatSync(e,r):f(e,r)};const{stat:p}=t;t.stat=(e,r,s)=>{const{isAsar:n}=splitPath(e);if("function"==typeof r&&(s=r,r={}),!n)return p(e,r,s);process.nextTick((()=>t.lstat(e,r,s)))},t.promises.stat=a.promisify(t.stat);const wrapRealpathSync=function(t){return function(e,r){const s=splitPath(e);if(!s.isAsar)return t.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.realpath(a);if(!1===c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});return i.join(t(n,r),c)}},{realpathSync:d}=t;t.realpathSync=wrapRealpathSync(d),t.realpathSync.native=wrapRealpathSync(d.native);const wrapRealpath=function(t){return function(e,r,s){const n=splitPath(e);if(!n.isAsar)return t.apply(this,arguments);const{asarPath:a,filePath:o}=n;arguments.length<3&&(s=r,r={});const c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.realpath(o);if(!1!==l)t(a,r,((t,e)=>{if(null===t){const t=i.join(e,l);s(null,t)}else s(t)}));else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}}},{realpath:I}=t;t.realpath=wrapRealpath(I),t.realpath.native=wrapRealpath(I.native),t.promises.realpath=a.promisify(t.realpath.native);const{exists:v}=t;t.exists=function exists(t,e){let r;try{r=splitPath(t)}catch{return void nextTick(e,[!1])}if(!r.isAsar)return v(t,e);const{asarPath:s,filePath:n}=r,i=getOrCreateArchive(s);if(!i){const t=createError("INVALID_ARCHIVE",{asarPath:s});return void nextTick(e,[t])}const a=!1!==i.stat(n);nextTick(e,[a])},t.exists[a.promisify.custom]=function exists(t){const e=splitPath(t);if(!e.isAsar)return v[a.promisify.custom](t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n){const t=createError("INVALID_ARCHIVE",{asarPath:r});return l.reject(t)}return l.resolve(!1!==n.stat(s))};const{existsSync:O}=t;t.existsSync=t=>{let e;try{e=splitPath(t)}catch{return!1}if(!e.isAsar)return O(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);return!!n&&!1!==n.stat(s)};const{access:g}=t;t.access=function(e,r,s){const n=splitPath(e);if(!n.isAsar)return g.apply(this,arguments);const{asarPath:i,filePath:a}=n;"function"==typeof r&&(s=r,r=t.constants.F_OK);const o=getOrCreateArchive(i);if(!o){const t=createError("INVALID_ARCHIVE",{asarPath:i});return void nextTick(s,[t])}const c=o.getFileInfo(a);if(!c){const t=createError("NOT_FOUND",{asarPath:i,filePath:a});return void nextTick(s,[t])}if(c.unpacked){const e=o.copyFileOut(a);return t.access(e,r,s)}if(o.stat(a))if(r&t.constants.W_OK){const t=createError("NO_ACCESS",{asarPath:i,filePath:a});nextTick(s,[t])}else nextTick(s);else{const t=createError("NOT_FOUND",{asarPath:i,filePath:a});nextTick(s,[t])}};const{access:m}=t.promises;t.promises.access=function(e,r){if(!splitPath(e).isAsar)return m.apply(this,arguments);return a.promisify(t.access)(e,r)};const{accessSync:S}=t;function fsReadFileAsar(e,r,n){const i=splitPath(e);if(i.isAsar){const{asarPath:e,filePath:a}=i;if("function"==typeof r)n=r,r={encoding:null};else if("string"==typeof r)r={encoding:r};else if(null==r)r={encoding:null};else if("object"!=typeof r)throw new TypeError("Bad arguments");const{encoding:o}=r,c=getOrCreateArchive(e);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:e});return void nextTick(n,[t])}const l=c.getFileInfo(a);if(!l){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}if(0===l.size)return void nextTick(n,[null,o?"":s.Buffer.alloc(0)]);if(l.unpacked){const e=c.copyFileOut(a);return t.readFile(e,r,n)}const f=s.Buffer.alloc(l.size),u=c.getFdAndValidateIntegrityLater();if(!(u>=0)){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}logASARAccess(e,a,l.offset),t.read(u,f,0,l.size,l.offset,(t=>{validateBufferIntegrity(f,l.integrity),n(t,o?f.toString(o):f)}))}}t.accessSync=function(e,r){const s=splitPath(e);if(!s.isAsar)return S.apply(this,arguments);const{asarPath:n,filePath:i}=s;null==r&&(r=t.constants.F_OK);const a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(o.unpacked){const e=a.copyFileOut(i);return t.accessSync(e,r)}if(!a.stat(i))throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(r&t.constants.W_OK)throw createError("NO_ACCESS",{asarPath:n,filePath:i})};const{readFile:D}=t;t.readFile=function(t,e,r){return splitPath(t).isAsar?fsReadFileAsar(t,e,r):D.apply(this,arguments)};const{readFile:R}=t.promises;function readFileFromArchiveSync(e,r){const{asarPath:n,filePath:i}=e,a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(0===o.size)return r?"":s.Buffer.alloc(0);if(o.unpacked){const e=a.copyFileOut(i);return t.readFileSync(e,r)}if(r){if("string"==typeof r)r={encoding:r};else if("object"!=typeof r)throw new TypeError("Bad arguments")}else r={encoding:null};const{encoding:c}=r,l=s.Buffer.alloc(o.size),f=a.getFdAndValidateIntegrityLater();if(!(f>=0))throw createError("NOT_FOUND",{asarPath:n,filePath:i});return logASARAccess(n,i,o.offset),t.readSync(f,l,0,o.size,o.offset),validateBufferIntegrity(l,o.integrity),c?l.toString(c):l}t.promises.readFile=function(t,e){if(!splitPath(t).isAsar)return R.apply(this,arguments);return a.promisify(fsReadFileAsar)(t,e)};const{readFileSync:T}=t;t.readFileSync=function(t,e){const r=splitPath(t);return r.isAsar?readFileFromArchiveSync(r,e):T.apply(this,arguments)};const processReaddirResult=t=>t.context.withFileTypes?function handleDirents({result:t,currentPath:e,context:r}){const s=t[0].length;for(let n=0;n<s;n++){const s=i.join(e,t[0][n]),a=splitPath(s);let o=t[1][n];if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)return;const e=t.stat(a.filePath);if(!e)continue;o=e.type}const c=_(e,t[0][n],o),l=u("fs").internalModuleStat(s);r.readdirResults.push(c),(c.isDirectory()||1===l)&&r.pathsQueue.push(i.join(c.path,c.name))}}(t):function handleFilePaths({result:t,currentPath:e,context:r}){for(let s=0;s<t.length;s++){const n=i.join(e,t[s]),a=i.relative(r.basePath,n),o=u("fs").internalModuleStat(n);r.readdirResults.push(a),1===o&&r.pathsQueue.push(n)}}(t);const{readdir:E}=t;t.readdir=function(e,r,s){if(F(s="function"==typeof r?r:s,"callback"),r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return void function readdirRecursive(t,e,r){const s={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};let n=0;!function read(t){const e=new h.FSReqCallback;e.oncomplete=(e,i)=>{e?r(e):void 0!==i?(processReaddirResult({result:i,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)):r(null,s.readdirResults)};const a=splitPath(t);if(a.isAsar){let e;const{asarPath:o,filePath:c}=a,l=getOrCreateArchive(o);if(!l){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(r,[t])}if(e=l.readdir(c),!e){const t=createError("NOT_FOUND",{asarPath:o,filePath:c});return void nextTick(r,[t])}s.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))]),processReaddirResult({result:e,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)}else h.readdir(t,s.encoding,s.withFileTypes,e)}(s.pathsQueue[n++])}(e,r,s);const n=splitPath(e);if(!n.isAsar)return E.apply(this,arguments);const{asarPath:a,filePath:o}=n,c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.readdir(o);if(l)if(r?.withFileTypes){const e=[];for(const r of l){const n=i.join(o,r),l=c.stat(n);if(!l){const t=createError("NOT_FOUND",{asarPath:a,filePath:n});return void nextTick(s,[t])}e.push(new t.Dirent(r,l.type))}nextTick(s,[null,e])}else nextTick(s,[null,l]);else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}};const{readdir:k}=t.promises;t.promises.readdir=async function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return async function readdirRecursivePromises(t,e){const r=[],s=splitPath(t);let n=[];const a=Boolean(e?.withFileTypes);let o=[];if(s.isAsar){const e=getOrCreateArchive(s.asarPath);if(!e)return r;const n=e.readdir(s.filePath);if(!n)return r;o=n,a&&(o=[[...o],o.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else o=await h.readdir(i.toNamespacedPath(t),e.encoding,a,b);if(n=[[t,o]],a)for(;n.length>0;){const{0:t,1:s}=n.pop();for(const a of getDirents(t,s))if(r.push(a),a.isDirectory()){const r=i.join(t,a.name),s=splitPath(r);let o;if(s.isAsar){const t=getOrCreateArchive(s.asarPath);if(!t)continue;const e=t.readdir(s.filePath);if(!e)continue;o=[[...e],e.map((t=>u("fs").internalModuleStat(i.join(r,t))))]}else o=await h.readdir(r,e.encoding,!0,b);n.push([r,o])}}else for(;n.length>0;){const{0:s,1:a}=n.pop();for(const o of a){const a=i.join(s,o),c=u("fs").internalModuleStat(a);if(r.push(i.relative(t,a)),1===c){const t=splitPath(a);let s=[];if(t.isAsar){const e=getOrCreateArchive(t.asarPath);if(!e)return;const n=e.readdir(t.filePath);if(!n)return r;s=n}else s=await h.readdir(i.toNamespacedPath(a),e.encoding,!1,b);n.push([a,s])}}}return r}(e,r);const s=splitPath(e);if(!s.isAsar)return k(e,r);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:n}));const c=o.readdir(a);if(!c)return l.reject(createError("NOT_FOUND",{asarPath:n,filePath:a}));if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return l.resolve(e)}return l.resolve(c)};const{readdirSync:V}=t;t.readdirSync=function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return function readdirSyncRecursive(t,e){const r={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};function read(t){let e;const s=splitPath(t);if(s.isAsar){const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return;if(e=o.readdir(a),!e)return;r.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else e=h.readdir(i.toNamespacedPath(t),r.encoding,r.withFileTypes);void 0!==e&&processReaddirResult({result:e,currentPath:t,context:r})}for(let t=0;t<r.pathsQueue.length;t++)read(r.pathsQueue[t]);return r.readdirResults}(e,r);const s=splitPath(e);if(!s.isAsar)return V.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.readdir(a);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return e}return c};u("modules").overrideReadFileSync((t=>{const e=splitPath(t);if(e.isAsar)try{return readFileFromArchiveSync(e,void 0)}catch{return!1}}));const{internalModuleStat:x}=h;u("fs").internalModuleStat=t=>{const e=splitPath(t);if(!e.isAsar)return x(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n)return-34;const i=n.stat(s);return i?i.type===w.kDirectory?1:0:-34};const{kUsePromises:b}=h;if("win32"===process.platform){const{mkdir:e}=t;t.mkdir=(t,r,s)=>{"function"==typeof r&&(s=r,r={});const n=splitPath(t);if(n.isAsar&&n.filePath.length>0){const t=createError("NOT_DIR");nextTick(s,[t])}else e(t,r,s)},t.promises.mkdir=a.promisify(t.mkdir);const{mkdirSync:r}=t;t.mkdirSync=function(t,e){const s=splitPath(t);if(s.isAsar&&s.filePath.length)throw createError("NOT_DIR");return r(t,e)}}function invokeWithNoAsar(t){return function(){const e=process.noAsar;process.noAsar=!0;try{return t.apply(this,arguments)}finally{process.noAsar=e}}}overrideAPI(t,"copyFile"),overrideAPISync(t,"copyFileSync"),overrideAPI(t,"open"),overrideAPISync(process,"dlopen",1),overrideAPISync(c._extensions,".node",1),overrideAPISync(t,"openSync");const overrideChildProcess=t=>{const{exec:e,execSync:r}=t;t.exec=invokeWithNoAsar(e),t.exec[a.promisify.custom]=A("exec",invokeWithNoAsar(e[a.promisify.custom])),t.execSync=invokeWithNoAsar(r),overrideAPI(t,"execFile"),overrideAPISync(t,"execFileSync")},C=new WeakSet;if(process.env.ELECTRON_EAGER_ASAR_HOOK_FOR_TESTING)overrideChildProcess(r("child_process"));else{const t=c._load;c._load=(e,...r)=>{const s=t(e,...r);if(("child_process"===e||"node:child_process"===e)&&!C.has(s)){C.add(s);overrideChildProcess(s)}return s}}}},buffer:t=>{t.exports=require("buffer")},child_process:t=>{t.exports=require("child_process")},crypto:t=>{t.exports=require("crypto")},fs:t=>{t.exports=require("fs")},module:t=>{t.exports=require("module")},os:t=>{t.exports=require("os")},path:t=>{t.exports=require("path")},util:t=>{t.exports=require("util")}},e={};function __webpack_require__(r){var s=e[r];if(void 0!==s)return s.exports;var n=e[r]={exports:{}};return t[r](n,n.exports,__webpack_require__),n.exports}var r={};(()=>{var t=r;Object.defineProperty(t,"__esModule",{value:!0});if((0,__webpack_require__("./lib/node/asar-fs-wrapper.ts").wrapFsWithAsar)(__webpack_require__("fs")),globalThis.blinkfetch){const t=["fetch","Response","FormData","Request","Headers","EventSource"];for(const e of t)globalThis[e]=globalThis[`blink${e}`]}const e=__webpack_require__("child_process"),s=e.fork;e.fork=(t,e,r)=>(null==e?e=[]:"object"!=typeof e||Array.isArray(e)||(r=e,e=[]),"string"!=typeof t||!Array.isArray(e)||"object"!=typeof r&&void 0!==r||((r=r??{}).env=Object.create(r.env||process.env),r.env.ELECTRON_RUN_AS_NODE="1",r.execPath||"darwin"!==process.platform||(r.execPath=process.helperExecPath)),s(t,e,r));const n=__webpack_require__("path"),i=__webpack_require__("module"),a=process.resourcesPath+n.sep,o=i._nodeModulePaths;i._nodeModulePaths=function(t){const e=o(t);return(n.resolve(t)+n.sep).startsWith(a)?e.filter((function(t){return t.startsWith(a)})):e}})()})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

Error: The specified module could not be found.
C:\Users\ygaba\source\repos\BPSR-Meter\node_modules\electron\dist\resources\build\Release\windivert.node
    at process.func [as dlopen] (node:electron/js2c/node_init:2:2617)
    at file:///C:/Users/ygaba/source/repos/BPSR-Meter/out/main/server.js:735:9
    at ModuleJob.run (node:internal/modules/esm/module_job:345:25)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:665:26)
    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:132:5) {
  code: 'ERR_DLOPEN_FAILED'
}

Node.js v22.20.0
[2025-10-25T01:34:47.085Z] SERVER PROCESS EXITED with code: 1, signal: null
[2025-10-25T01:34:47.086Z] SERVER PROCESS CLOSED with code: 1
[2025-10-25T01:34:56.743Z] ERROR: Server did not respond in time (10s timeout)
[2025-10-25T01:34:57.638Z] All windows closed
[2025-10-25T01:34:57.639Z] Closing application (not macOS)
[2025-10-25T01:34:57.639Z] App closing, cleaning up processes...
[2025-10-25T01:37:33.139Z] ==== ELECTRON START ====
[2025-10-25T01:37:33.204Z] Electron app ready, starting createWindow()
[2025-10-25T01:37:33.205Z] === STARTING CREATEWINDOW ===
[2025-10-25T01:37:33.206Z] Node.js process: v22.20.0
[2025-10-25T01:37:33.206Z] Electron version: 38.3.0
[2025-10-25T01:37:33.207Z] Current directory: C:\Users\ygaba\source\repos\BPSR-Meter\out\main
[2025-10-25T01:37:33.207Z] Attempting to kill processes on port 8989...
[2025-10-25T01:37:33.275Z] Searching for available port starting from: 8989
[2025-10-25T01:37:33.276Z] Checking port availability: 8989
[2025-10-25T01:37:33.278Z] Port 8989 is available
[2025-10-25T01:37:33.279Z] Available port found: 8989
[2025-10-25T01:37:33.338Z] User data path: C:\Users\ygaba\AppData\Roaming\bpsr-meter
[2025-10-25T01:37:33.339Z] Launching server.js on port 8989 with path: C:\Users\ygaba\source\repos\BPSR-Meter\out\main\server.js
[2025-10-25T01:37:33.682Z] SERVER STDERR: node:electron/js2c/node_init:2
(()=>{"use strict";var t={"./lib/node/asar-fs-wrapper.ts":(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.wrapFsWithAsar=void 0;const s=r("buffer"),n=r("fs"),i=r("path"),a=r("util"),o=process._linkedBinding("electron_common_asar"),c=r("module"),l=global.Promise,f=process.env.ELECTRON_NO_ASAR&&"browser"!==process.type&&"renderer"!==process.type,u=process.internalBinding;delete process.internalBinding;const nextTick=(t,e=[])=>{process.nextTick((()=>t(...e)))},h=u("fs"),p=new Map,getOrCreateArchive=t=>{if(p.has(t))return p.get(t);try{const e=new o.Archive(t);return p.set(t,e),e}catch{return null}};process._getOrCreateArchive=getOrCreateArchive;const d=/\.asar/i,{getValidatedPath:y,getOptions:P,getDirent:_}=require("internal/fs/utils"),{assignFunctionName:A}=require("internal/util"),{validateBoolean:N,validateFunction:F}=require("internal/validators"),{URL:I}=require("internal/url"),splitPath=t=>{if(process.noAsar||f)return{isAsar:!1};let e=t;return s.Buffer.isBuffer(t)&&(e=t.toString()),e instanceof I&&(e=y(e)),"string"!=typeof e?{isAsar:!1}:d.test(e)?o.splitPath(i.normalize(e)):{isAsar:!1}};let v=0;const O=process.getuid?.()??0,g=process.getgid?.()??0,m=new Date;function getDirents(t,{0:e,1:r}){for(let s=0;s<e.length;s++){let n=r[s];const a=splitPath(i.join(t,e[s]));if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)continue;const e=t.stat(a.filePath);if(!e)continue;n=e.type}e[s]=_(t,e[s],n)}return e}var w;!function(t){t[t.kFile=n.constants.UV_DIRENT_FILE]="kFile",t[t.kDirectory=n.constants.UV_DIRENT_DIR]="kDirectory",t[t.kLink=n.constants.UV_DIRENT_LINK]="kLink"}(w||(w={}));const S=new Map([[w.kFile,n.constants.S_IFREG],[w.kDirectory,n.constants.S_IFDIR],[w.kLink,n.constants.S_IFLNK]]),asarStatsToFsStats=function(t){const{Stats:e}=r("fs");return new e(1,n.constants.S_IROTH|n.constants.S_IRGRP|n.constants.S_IRUSR|n.constants.S_IWUSR|S.get(t.type),1,O,g,0,void 0,++v,t.size,void 0,m.getTime(),m.getTime(),m.getTime(),m.getTime())},createError=(t,{asarPath:e,filePath:r}={})=>{let s;switch(t){case"NOT_FOUND":s=new Error(`ENOENT, ${r} not found in ${e}`),s.code="ENOENT",s.errno=-2;break;case"NOT_DIR":s=new Error("ENOTDIR, not a directory"),s.code="ENOTDIR",s.errno=-20;break;case"NO_ACCESS":s=new Error(`EACCES: permission denied, access '${r}'`),s.code="EACCES",s.errno=-13;break;case"INVALID_ARCHIVE":s=new Error(`Invalid package ${e}`);break;default:throw new Error(`Invalid error type "${t}" passed to createError.`)}return s},overrideAPISync=function(t,e,r,s=!1){null==r&&(r=0);const n=t[e],func=function(...t){const e=t[r],s=splitPath(e);if(!s.isAsar)return n.apply(this,t);const{asarPath:i,filePath:a}=s,o=getOrCreateArchive(i);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:i});const c=o.copyFileOut(a);if(!c)throw createError("NOT_FOUND",{asarPath:i,filePath:a});return t[r]=c,n.apply(this,t)};if(s)return func;t[e]=func},overrideAPI=function(t,e,r){null==r&&(r=0);const s=t[e];t[e]=function(...n){const i=n[r],a=splitPath(i);if(!a.isAsar)return s.apply(this,n);const{asarPath:o,filePath:c}=a,l=n[n.length-1];if("function"!=typeof l)return overrideAPISync(t,e,r,!0).apply(this,n);const f=getOrCreateArchive(o);if(!f){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(l,[t])}const u=f.copyFileOut(c);if(u)return n[r]=u,s.apply(this,n);{const t=createError("NOT_FOUND",{asarPath:o,filePath:c});nextTick(l,[t])}},s[a.promisify.custom]&&(t[e][a.promisify.custom]=A(e,makePromiseFunction(s[a.promisify.custom],r))),t.promises&&t.promises[e]&&(t.promises[e]=makePromiseFunction(t.promises[e],r))};let D;function validateBufferIntegrity(t,e){if(!e)return;D=D||r("crypto");const s=D.createHash(e.algorithm).update(t).digest("hex");s!==e.hash&&(console.error(`ASAR Integrity Violation: got a hash mismatch (${s} vs ${e.hash})`),process.exit(1))}const makePromiseFunction=function(t,e){return function(...r){const s=r[e],n=splitPath(s);if(!n.isAsar)return t.apply(this,r);const{asarPath:i,filePath:a}=n,o=getOrCreateArchive(i);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:i}));const c=o.copyFileOut(a);return c?(r[e]=c,t.apply(this,r)):l.reject(createError("NOT_FOUND",{asarPath:i,filePath:a}))}};e.wrapFsWithAsar=t=>{const e=new Map,logASARAccess=(s,n,a)=>{if(process.env.ELECTRON_LOG_ASAR_READS){if(!e.has(s)){const n=`${i.basename(s,".asar")}-access-log.txt`,a=i.join(r("os").tmpdir(),n);e.set(s,t.openSync(a,"a"))}t.writeSync(e.get(s),`${a}: ${n}\n`)}},shouldThrowStatError=t=>!t||"object"!=typeof t||!1!==t.throwIfNoEntry,{lstatSync:n}=t;t.lstatSync=(t,e)=>{const r=splitPath(t);if(!r.isAsar)return n(t,e);const{asarPath:s,filePath:i}=r,a=getOrCreateArchive(s);if(!a){if(shouldThrowStatError(e))throw createError("INVALID_ARCHIVE",{asarPath:s});return null}const o=a.stat(i);if(!o){if(shouldThrowStatError(e))throw createError("NOT_FOUND",{asarPath:s,filePath:i});return null}return asarStatsToFsStats(o)};const{lstat:o}=t;t.lstat=(t,e,r)=>{const s=splitPath(t);if("function"==typeof e&&(r=e,e={}),!s.isAsar)return o(t,e,r);const{asarPath:n,filePath:i}=s,a=getOrCreateArchive(n);if(!a){const t=createError("INVALID_ARCHIVE",{asarPath:n});return void nextTick(r,[t])}const c=a.stat(i);if(!c){const t=createError("NOT_FOUND",{asarPath:n,filePath:i});return void nextTick(r,[t])}const l=asarStatsToFsStats(c);nextTick(r,[null,l])},t.promises.lstat=a.promisify(t.lstat);const{statSync:f}=t;t.statSync=(e,r)=>{const{isAsar:s}=splitPath(e);return s?t.lstatSync(e,r):f(e,r)};const{stat:p}=t;t.stat=(e,r,s)=>{const{isAsar:n}=splitPath(e);if("function"==typeof r&&(s=r,r={}),!n)return p(e,r,s);process.nextTick((()=>t.lstat(e,r,s)))},t.promises.stat=a.promisify(t.stat);const wrapRealpathSync=function(t){return function(e,r){const s=splitPath(e);if(!s.isAsar)return t.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.realpath(a);if(!1===c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});return i.join(t(n,r),c)}},{realpathSync:d}=t;t.realpathSync=wrapRealpathSync(d),t.realpathSync.native=wrapRealpathSync(d.native);const wrapRealpath=function(t){return function(e,r,s){const n=splitPath(e);if(!n.isAsar)return t.apply(this,arguments);const{asarPath:a,filePath:o}=n;arguments.length<3&&(s=r,r={});const c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.realpath(o);if(!1!==l)t(a,r,((t,e)=>{if(null===t){const t=i.join(e,l);s(null,t)}else s(t)}));else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}}},{realpath:I}=t;t.realpath=wrapRealpath(I),t.realpath.native=wrapRealpath(I.native),t.promises.realpath=a.promisify(t.realpath.native);const{exists:v}=t;t.exists=function exists(t,e){let r;try{r=splitPath(t)}catch{return void nextTick(e,[!1])}if(!r.isAsar)return v(t,e);const{asarPath:s,filePath:n}=r,i=getOrCreateArchive(s);if(!i){const t=createError("INVALID_ARCHIVE",{asarPath:s});return void nextTick(e,[t])}const a=!1!==i.stat(n);nextTick(e,[a])},t.exists[a.promisify.custom]=function exists(t){const e=splitPath(t);if(!e.isAsar)return v[a.promisify.custom](t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n){const t=createError("INVALID_ARCHIVE",{asarPath:r});return l.reject(t)}return l.resolve(!1!==n.stat(s))};const{existsSync:O}=t;t.existsSync=t=>{let e;try{e=splitPath(t)}catch{return!1}if(!e.isAsar)return O(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);return!!n&&!1!==n.stat(s)};const{access:g}=t;t.access=function(e,r,s){const n=splitPath(e);if(!n.isAsar)return g.apply(this,arguments);const{asarPath:i,filePath:a}=n;"function"==typeof r&&(s=r,r=t.constants.F_OK);const o=getOrCreateArchive(i);if(!o){const t=createError("INVALID_ARCHIVE",{asarPath:i});return void nextTick(s,[t])}const c=o.getFileInfo(a);if(!c){const t=createError("NOT_FOUND",{asarPath:i,filePath:a});return void nextTick(s,[t])}if(c.unpacked){const e=o.copyFileOut(a);return t.access(e,r,s)}if(o.stat(a))if(r&t.constants.W_OK){const t=createError("NO_ACCESS",{asarPath:i,filePath:a});nextTick(s,[t])}else nextTick(s);else{const t=createError("NOT_FOUND",{asarPath:i,filePath:a});nextTick(s,[t])}};const{access:m}=t.promises;t.promises.access=function(e,r){if(!splitPath(e).isAsar)return m.apply(this,arguments);return a.promisify(t.access)(e,r)};const{accessSync:S}=t;function fsReadFileAsar(e,r,n){const i=splitPath(e);if(i.isAsar){const{asarPath:e,filePath:a}=i;if("function"==typeof r)n=r,r={encoding:null};else if("string"==typeof r)r={encoding:r};else if(null==r)r={encoding:null};else if("object"!=typeof r)throw new TypeError("Bad arguments");const{encoding:o}=r,c=getOrCreateArchive(e);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:e});return void nextTick(n,[t])}const l=c.getFileInfo(a);if(!l){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}if(0===l.size)return void nextTick(n,[null,o?"":s.Buffer.alloc(0)]);if(l.unpacked){const e=c.copyFileOut(a);return t.readFile(e,r,n)}const f=s.Buffer.alloc(l.size),u=c.getFdAndValidateIntegrityLater();if(!(u>=0)){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}logASARAccess(e,a,l.offset),t.read(u,f,0,l.size,l.offset,(t=>{validateBufferIntegrity(f,l.integrity),n(t,o?f.toString(o):f)}))}}t.accessSync=function(e,r){const s=splitPath(e);if(!s.isAsar)return S.apply(this,arguments);const{asarPath:n,filePath:i}=s;null==r&&(r=t.constants.F_OK);const a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(o.unpacked){const e=a.copyFileOut(i);return t.accessSync(e,r)}if(!a.stat(i))throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(r&t.constants.W_OK)throw createError("NO_ACCESS",{asarPath:n,filePath:i})};const{readFile:D}=t;t.readFile=function(t,e,r){return splitPath(t).isAsar?fsReadFileAsar(t,e,r):D.apply(this,arguments)};const{readFile:R}=t.promises;function readFileFromArchiveSync(e,r){const{asarPath:n,filePath:i}=e,a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(0===o.size)return r?"":s.Buffer.alloc(0);if(o.unpacked){const e=a.copyFileOut(i);return t.readFileSync(e,r)}if(r){if("string"==typeof r)r={encoding:r};else if("object"!=typeof r)throw new TypeError("Bad arguments")}else r={encoding:null};const{encoding:c}=r,l=s.Buffer.alloc(o.size),f=a.getFdAndValidateIntegrityLater();if(!(f>=0))throw createError("NOT_FOUND",{asarPath:n,filePath:i});return logASARAccess(n,i,o.offset),t.readSync(f,l,0,o.size,o.offset),validateBufferIntegrity(l,o.integrity),c?l.toString(c):l}t.promises.readFile=function(t,e){if(!splitPath(t).isAsar)return R.apply(this,arguments);return a.promisify(fsReadFileAsar)(t,e)};const{readFileSync:T}=t;t.readFileSync=function(t,e){const r=splitPath(t);return r.isAsar?readFileFromArchiveSync(r,e):T.apply(this,arguments)};const processReaddirResult=t=>t.context.withFileTypes?function handleDirents({result:t,currentPath:e,context:r}){const s=t[0].length;for(let n=0;n<s;n++){const s=i.join(e,t[0][n]),a=splitPath(s);let o=t[1][n];if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)return;const e=t.stat(a.filePath);if(!e)continue;o=e.type}const c=_(e,t[0][n],o),l=u("fs").internalModuleStat(s);r.readdirResults.push(c),(c.isDirectory()||1===l)&&r.pathsQueue.push(i.join(c.path,c.name))}}(t):function handleFilePaths({result:t,currentPath:e,context:r}){for(let s=0;s<t.length;s++){const n=i.join(e,t[s]),a=i.relative(r.basePath,n),o=u("fs").internalModuleStat(n);r.readdirResults.push(a),1===o&&r.pathsQueue.push(n)}}(t);const{readdir:E}=t;t.readdir=function(e,r,s){if(F(s="function"==typeof r?r:s,"callback"),r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return void function readdirRecursive(t,e,r){const s={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};let n=0;!function read(t){const e=new h.FSReqCallback;e.oncomplete=(e,i)=>{e?r(e):void 0!==i?(processReaddirResult({result:i,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)):r(null,s.readdirResults)};const a=splitPath(t);if(a.isAsar){let e;const{asarPath:o,filePath:c}=a,l=getOrCreateArchive(o);if(!l){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(r,[t])}if(e=l.readdir(c),!e){const t=createError("NOT_FOUND",{asarPath:o,filePath:c});return void nextTick(r,[t])}s.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))]),processReaddirResult({result:e,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)}else h.readdir(t,s.encoding,s.withFileTypes,e)}(s.pathsQueue[n++])}(e,r,s);const n=splitPath(e);if(!n.isAsar)return E.apply(this,arguments);const{asarPath:a,filePath:o}=n,c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.readdir(o);if(l)if(r?.withFileTypes){const e=[];for(const r of l){const n=i.join(o,r),l=c.stat(n);if(!l){const t=createError("NOT_FOUND",{asarPath:a,filePath:n});return void nextTick(s,[t])}e.push(new t.Dirent(r,l.type))}nextTick(s,[null,e])}else nextTick(s,[null,l]);else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}};const{readdir:k}=t.promises;t.promises.readdir=async function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return async function readdirRecursivePromises(t,e){const r=[],s=splitPath(t);let n=[];const a=Boolean(e?.withFileTypes);let o=[];if(s.isAsar){const e=getOrCreateArchive(s.asarPath);if(!e)return r;const n=e.readdir(s.filePath);if(!n)return r;o=n,a&&(o=[[...o],o.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else o=await h.readdir(i.toNamespacedPath(t),e.encoding,a,b);if(n=[[t,o]],a)for(;n.length>0;){const{0:t,1:s}=n.pop();for(const a of getDirents(t,s))if(r.push(a),a.isDirectory()){const r=i.join(t,a.name),s=splitPath(r);let o;if(s.isAsar){const t=getOrCreateArchive(s.asarPath);if(!t)continue;const e=t.readdir(s.filePath);if(!e)continue;o=[[...e],e.map((t=>u("fs").internalModuleStat(i.join(r,t))))]}else o=await h.readdir(r,e.encoding,!0,b);n.push([r,o])}}else for(;n.length>0;){const{0:s,1:a}=n.pop();for(const o of a){const a=i.join(s,o),c=u("fs").internalModuleStat(a);if(r.push(i.relative(t,a)),1===c){const t=splitPath(a);let s=[];if(t.isAsar){const e=getOrCreateArchive(t.asarPath);if(!e)return;const n=e.readdir(t.filePath);if(!n)return r;s=n}else s=await h.readdir(i.toNamespacedPath(a),e.encoding,!1,b);n.push([a,s])}}}return r}(e,r);const s=splitPath(e);if(!s.isAsar)return k(e,r);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:n}));const c=o.readdir(a);if(!c)return l.reject(createError("NOT_FOUND",{asarPath:n,filePath:a}));if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return l.resolve(e)}return l.resolve(c)};const{readdirSync:V}=t;t.readdirSync=function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return function readdirSyncRecursive(t,e){const r={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};function read(t){let e;const s=splitPath(t);if(s.isAsar){const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return;if(e=o.readdir(a),!e)return;r.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else e=h.readdir(i.toNamespacedPath(t),r.encoding,r.withFileTypes);void 0!==e&&processReaddirResult({result:e,currentPath:t,context:r})}for(let t=0;t<r.pathsQueue.length;t++)read(r.pathsQueue[t]);return r.readdirResults}(e,r);const s=splitPath(e);if(!s.isAsar)return V.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.readdir(a);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return e}return c};u("modules").overrideReadFileSync((t=>{const e=splitPath(t);if(e.isAsar)try{return readFileFromArchiveSync(e,void 0)}catch{return!1}}));const{internalModuleStat:x}=h;u("fs").internalModuleStat=t=>{const e=splitPath(t);if(!e.isAsar)return x(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n)return-34;const i=n.stat(s);return i?i.type===w.kDirectory?1:0:-34};const{kUsePromises:b}=h;if("win32"===process.platform){const{mkdir:e}=t;t.mkdir=(t,r,s)=>{"function"==typeof r&&(s=r,r={});const n=splitPath(t);if(n.isAsar&&n.filePath.length>0){const t=createError("NOT_DIR");nextTick(s,[t])}else e(t,r,s)},t.promises.mkdir=a.promisify(t.mkdir);const{mkdirSync:r}=t;t.mkdirSync=function(t,e){const s=splitPath(t);if(s.isAsar&&s.filePath.length)throw createError("NOT_DIR");return r(t,e)}}function invokeWithNoAsar(t){return function(){const e=process.noAsar;process.noAsar=!0;try{return t.apply(this,arguments)}finally{process.noAsar=e}}}overrideAPI(t,"copyFile"),overrideAPISync(t,"copyFileSync"),overrideAPI(t,"open"),overrideAPISync(process,"dlopen",1),overrideAPISync(c._extensions,".node",1),overrideAPISync(t,"openSync");const overrideChildProcess=t=>{const{exec:e,execSync:r}=t;t.exec=invokeWithNoAsar(e),t.exec[a.promisify.custom]=A("exec",invokeWithNoAsar(e[a.promisify.custom])),t.execSync=invokeWithNoAsar(r),overrideAPI(t,"execFile"),overrideAPISync(t,"execFileSync")},C=new WeakSet;if(process.env.ELECTRON_EAGER_ASAR_HOOK_FOR_TESTING)overrideChildProcess(r("child_process"));else{const t=c._load;c._load=(e,...r)=>{const s=t(e,...r);if(("child_process"===e||"node:child_process"===e)&&!C.has(s)){C.add(s);overrideChildProcess(s)}return s}}}},buffer:t=>{t.exports=require("buffer")},child_process:t=>{t.exports=require("child_process")},crypto:t=>{t.exports=require("crypto")},fs:t=>{t.exports=require("fs")},module:t=>{t.exports=require("module")},os:t=>{t.exports=require("os")},path:t=>{t.exports=require("path")},util:t=>{t.exports=require("util")}},e={};function __webpack_require__(r){var s=e[r];if(void 0!==s)return s.exports;var n=e[r]={exports:{}};return t[r](n,n.exports,__webpack_require__),n.exports}var r={};(()=>{var t=r;Object.defineProperty(t,"__esModule",{value:!0});if((0,__webpack_require__("./lib/node/asar-fs-wrapper.ts").wrapFsWithAsar)(__webpack_require__("fs")),globalThis.blinkfetch){const t=["fetch","Response","FormData","Request","Headers","EventSource"];for(const e of t)globalThis[e]=globalThis[`blink${e}`]}const e=__webpack_require__("child_process"),s=e.fork;e.fork=(t,e,r)=>(null==e?e=[]:"object"!=typeof e||Array.isArray(e)||(r=e,e=[]),"string"!=typeof t||!Array.isArray(e)||"object"!=typeof r&&void 0!==r||((r=r??{}).env=Object.create(r.env||process.env),r.env.ELECTRON_RUN_AS_NODE="1",r.execPath||"darwin"!==process.platform||(r.execPath=process.helperExecPath)),s(t,e,r));const n=__webpack_require__("path"),i=__webpack_require__("module"),a=process.resourcesPath+n.sep,o=i._nodeModulePaths;i._nodeModulePaths=function(t){const e=o(t);return(n.resolve(t)+n.sep).startsWith(a)?e.filter((function(t){return t.startsWith(a)})):e}})()})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

Error: The specified module could not be found.
C:\Users\ygaba\source\repos\BPSR-Meter\node_modules\electron\dist\resources\build\Release\windivert.node
    at process.func [as dlopen] (node:electron/js2c/node_init:2:2617)
    at file:///C:/Users/ygaba/source/repos/BPSR-Meter/out/main/server.js:735:9
    at ModuleJob.run (node:internal/modules/esm/module_job:345:25)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:665:26)
    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:132:5) {
  code: 'ERR_DLOPEN_FAILED'
}

Node.js v22.20.0
[2025-10-25T01:37:33.692Z] SERVER PROCESS EXITED with code: 1, signal: null
[2025-10-25T01:37:33.693Z] SERVER PROCESS CLOSED with code: 1
[2025-10-25T01:37:43.358Z] ERROR: Server did not respond in time (10s timeout)
[2025-10-25T01:37:55.325Z] All windows closed
[2025-10-25T01:37:55.327Z] Closing application (not macOS)
[2025-10-25T01:37:55.327Z] App closing, cleaning up processes...
[2025-10-25T01:38:53.225Z] ==== ELECTRON START ====
[2025-10-25T01:38:53.285Z] Electron app ready, starting createWindow()
[2025-10-25T01:38:53.287Z] === STARTING CREATEWINDOW ===
[2025-10-25T01:38:53.288Z] Node.js process: v22.20.0
[2025-10-25T01:38:53.289Z] Electron version: 38.3.0
[2025-10-25T01:38:53.289Z] Current directory: C:\Users\ygaba\source\repos\BPSR-Meter\out\main
[2025-10-25T01:38:53.290Z] Attempting to kill processes on port 8989...
[2025-10-25T01:38:53.356Z] Searching for available port starting from: 8989
[2025-10-25T01:38:53.356Z] Checking port availability: 8989
[2025-10-25T01:38:53.359Z] Port 8989 is available
[2025-10-25T01:38:53.360Z] Available port found: 8989
[2025-10-25T01:38:53.423Z] User data path: C:\Users\ygaba\AppData\Roaming\bpsr-meter
[2025-10-25T01:38:53.423Z] Launching server.js on port 8989 with path: C:\Users\ygaba\source\repos\BPSR-Meter\out\main\server.js
[2025-10-25T01:38:53.796Z] SERVER STDERR: node:electron/js2c/node_init:2
(()=>{"use strict";var t={"./lib/node/asar-fs-wrapper.ts":(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.wrapFsWithAsar=void 0;const s=r("buffer"),n=r("fs"),i=r("path"),a=r("util"),o=process._linkedBinding("electron_common_asar"),c=r("module"),l=global.Promise,f=process.env.ELECTRON_NO_ASAR&&"browser"!==process.type&&"renderer"!==process.type,u=process.internalBinding;delete process.internalBinding;const nextTick=(t,e=[])=>{process.nextTick((()=>t(...e)))},h=u("fs"),p=new Map,getOrCreateArchive=t=>{if(p.has(t))return p.get(t);try{const e=new o.Archive(t);return p.set(t,e),e}catch{return null}};process._getOrCreateArchive=getOrCreateArchive;const d=/\.asar/i,{getValidatedPath:y,getOptions:P,getDirent:_}=require("internal/fs/utils"),{assignFunctionName:A}=require("internal/util"),{validateBoolean:N,validateFunction:F}=require("internal/validators"),{URL:I}=require("internal/url"),splitPath=t=>{if(process.noAsar||f)return{isAsar:!1};let e=t;return s.Buffer.isBuffer(t)&&(e=t.toString()),e instanceof I&&(e=y(e)),"string"!=typeof e?{isAsar:!1}:d.test(e)?o.splitPath(i.normalize(e)):{isAsar:!1}};let v=0;const O=process.getuid?.()??0,g=process.getgid?.()??0,m=new Date;function getDirents(t,{0:e,1:r}){for(let s=0;s<e.length;s++){let n=r[s];const a=splitPath(i.join(t,e[s]));if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)continue;const e=t.stat(a.filePath);if(!e)continue;n=e.type}e[s]=_(t,e[s],n)}return e}var w;!function(t){t[t.kFile=n.constants.UV_DIRENT_FILE]="kFile",t[t.kDirectory=n.constants.UV_DIRENT_DIR]="kDirectory",t[t.kLink=n.constants.UV_DIRENT_LINK]="kLink"}(w||(w={}));const S=new Map([[w.kFile,n.constants.S_IFREG],[w.kDirectory,n.constants.S_IFDIR],[w.kLink,n.constants.S_IFLNK]]),asarStatsToFsStats=function(t){const{Stats:e}=r("fs");return new e(1,n.constants.S_IROTH|n.constants.S_IRGRP|n.constants.S_IRUSR|n.constants.S_IWUSR|S.get(t.type),1,O,g,0,void 0,++v,t.size,void 0,m.getTime(),m.getTime(),m.getTime(),m.getTime())},createError=(t,{asarPath:e,filePath:r}={})=>{let s;switch(t){case"NOT_FOUND":s=new Error(`ENOENT, ${r} not found in ${e}`),s.code="ENOENT",s.errno=-2;break;case"NOT_DIR":s=new Error("ENOTDIR, not a directory"),s.code="ENOTDIR",s.errno=-20;break;case"NO_ACCESS":s=new Error(`EACCES: permission denied, access '${r}'`),s.code="EACCES",s.errno=-13;break;case"INVALID_ARCHIVE":s=new Error(`Invalid package ${e}`);break;default:throw new Error(`Invalid error type "${t}" passed to createError.`)}return s},overrideAPISync=function(t,e,r,s=!1){null==r&&(r=0);const n=t[e],func=function(...t){const e=t[r],s=splitPath(e);if(!s.isAsar)return n.apply(this,t);const{asarPath:i,filePath:a}=s,o=getOrCreateArchive(i);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:i});const c=o.copyFileOut(a);if(!c)throw createError("NOT_FOUND",{asarPath:i,filePath:a});return t[r]=c,n.apply(this,t)};if(s)return func;t[e]=func},overrideAPI=function(t,e,r){null==r&&(r=0);const s=t[e];t[e]=function(...n){const i=n[r],a=splitPath(i);if(!a.isAsar)return s.apply(this,n);const{asarPath:o,filePath:c}=a,l=n[n.length-1];if("function"!=typeof l)return overrideAPISync(t,e,r,!0).apply(this,n);const f=getOrCreateArchive(o);if(!f){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(l,[t])}const u=f.copyFileOut(c);if(u)return n[r]=u,s.apply(this,n);{const t=createError("NOT_FOUND",{asarPath:o,filePath:c});nextTick(l,[t])}},s[a.promisify.custom]&&(t[e][a.promisify.custom]=A(e,makePromiseFunction(s[a.promisify.custom],r))),t.promises&&t.promises[e]&&(t.promises[e]=makePromiseFunction(t.promises[e],r))};let D;function validateBufferIntegrity(t,e){if(!e)return;D=D||r("crypto");const s=D.createHash(e.algorithm).update(t).digest("hex");s!==e.hash&&(console.error(`ASAR Integrity Violation: got a hash mismatch (${s} vs ${e.hash})`),process.exit(1))}const makePromiseFunction=function(t,e){return function(...r){const s=r[e],n=splitPath(s);if(!n.isAsar)return t.apply(this,r);const{asarPath:i,filePath:a}=n,o=getOrCreateArchive(i);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:i}));const c=o.copyFileOut(a);return c?(r[e]=c,t.apply(this,r)):l.reject(createError("NOT_FOUND",{asarPath:i,filePath:a}))}};e.wrapFsWithAsar=t=>{const e=new Map,logASARAccess=(s,n,a)=>{if(process.env.ELECTRON_LOG_ASAR_READS){if(!e.has(s)){const n=`${i.basename(s,".asar")}-access-log.txt`,a=i.join(r("os").tmpdir(),n);e.set(s,t.openSync(a,"a"))}t.writeSync(e.get(s),`${a}: ${n}\n`)}},shouldThrowStatError=t=>!t||"object"!=typeof t||!1!==t.throwIfNoEntry,{lstatSync:n}=t;t.lstatSync=(t,e)=>{const r=splitPath(t);if(!r.isAsar)return n(t,e);const{asarPath:s,filePath:i}=r,a=getOrCreateArchive(s);if(!a){if(shouldThrowStatError(e))throw createError("INVALID_ARCHIVE",{asarPath:s});return null}const o=a.stat(i);if(!o){if(shouldThrowStatError(e))throw createError("NOT_FOUND",{asarPath:s,filePath:i});return null}return asarStatsToFsStats(o)};const{lstat:o}=t;t.lstat=(t,e,r)=>{const s=splitPath(t);if("function"==typeof e&&(r=e,e={}),!s.isAsar)return o(t,e,r);const{asarPath:n,filePath:i}=s,a=getOrCreateArchive(n);if(!a){const t=createError("INVALID_ARCHIVE",{asarPath:n});return void nextTick(r,[t])}const c=a.stat(i);if(!c){const t=createError("NOT_FOUND",{asarPath:n,filePath:i});return void nextTick(r,[t])}const l=asarStatsToFsStats(c);nextTick(r,[null,l])},t.promises.lstat=a.promisify(t.lstat);const{statSync:f}=t;t.statSync=(e,r)=>{const{isAsar:s}=splitPath(e);return s?t.lstatSync(e,r):f(e,r)};const{stat:p}=t;t.stat=(e,r,s)=>{const{isAsar:n}=splitPath(e);if("function"==typeof r&&(s=r,r={}),!n)return p(e,r,s);process.nextTick((()=>t.lstat(e,r,s)))},t.promises.stat=a.promisify(t.stat);const wrapRealpathSync=function(t){return function(e,r){const s=splitPath(e);if(!s.isAsar)return t.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.realpath(a);if(!1===c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});return i.join(t(n,r),c)}},{realpathSync:d}=t;t.realpathSync=wrapRealpathSync(d),t.realpathSync.native=wrapRealpathSync(d.native);const wrapRealpath=function(t){return function(e,r,s){const n=splitPath(e);if(!n.isAsar)return t.apply(this,arguments);const{asarPath:a,filePath:o}=n;arguments.length<3&&(s=r,r={});const c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.realpath(o);if(!1!==l)t(a,r,((t,e)=>{if(null===t){const t=i.join(e,l);s(null,t)}else s(t)}));else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}}},{realpath:I}=t;t.realpath=wrapRealpath(I),t.realpath.native=wrapRealpath(I.native),t.promises.realpath=a.promisify(t.realpath.native);const{exists:v}=t;t.exists=function exists(t,e){let r;try{r=splitPath(t)}catch{return void nextTick(e,[!1])}if(!r.isAsar)return v(t,e);const{asarPath:s,filePath:n}=r,i=getOrCreateArchive(s);if(!i){const t=createError("INVALID_ARCHIVE",{asarPath:s});return void nextTick(e,[t])}const a=!1!==i.stat(n);nextTick(e,[a])},t.exists[a.promisify.custom]=function exists(t){const e=splitPath(t);if(!e.isAsar)return v[a.promisify.custom](t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n){const t=createError("INVALID_ARCHIVE",{asarPath:r});return l.reject(t)}return l.resolve(!1!==n.stat(s))};const{existsSync:O}=t;t.existsSync=t=>{let e;try{e=splitPath(t)}catch{return!1}if(!e.isAsar)return O(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);return!!n&&!1!==n.stat(s)};const{access:g}=t;t.access=function(e,r,s){const n=splitPath(e);if(!n.isAsar)return g.apply(this,arguments);const{asarPath:i,filePath:a}=n;"function"==typeof r&&(s=r,r=t.constants.F_OK);const o=getOrCreateArchive(i);if(!o){const t=createError("INVALID_ARCHIVE",{asarPath:i});return void nextTick(s,[t])}const c=o.getFileInfo(a);if(!c){const t=createError("NOT_FOUND",{asarPath:i,filePath:a});return void nextTick(s,[t])}if(c.unpacked){const e=o.copyFileOut(a);return t.access(e,r,s)}if(o.stat(a))if(r&t.constants.W_OK){const t=createError("NO_ACCESS",{asarPath:i,filePath:a});nextTick(s,[t])}else nextTick(s);else{const t=createError("NOT_FOUND",{asarPath:i,filePath:a});nextTick(s,[t])}};const{access:m}=t.promises;t.promises.access=function(e,r){if(!splitPath(e).isAsar)return m.apply(this,arguments);return a.promisify(t.access)(e,r)};const{accessSync:S}=t;function fsReadFileAsar(e,r,n){const i=splitPath(e);if(i.isAsar){const{asarPath:e,filePath:a}=i;if("function"==typeof r)n=r,r={encoding:null};else if("string"==typeof r)r={encoding:r};else if(null==r)r={encoding:null};else if("object"!=typeof r)throw new TypeError("Bad arguments");const{encoding:o}=r,c=getOrCreateArchive(e);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:e});return void nextTick(n,[t])}const l=c.getFileInfo(a);if(!l){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}if(0===l.size)return void nextTick(n,[null,o?"":s.Buffer.alloc(0)]);if(l.unpacked){const e=c.copyFileOut(a);return t.readFile(e,r,n)}const f=s.Buffer.alloc(l.size),u=c.getFdAndValidateIntegrityLater();if(!(u>=0)){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}logASARAccess(e,a,l.offset),t.read(u,f,0,l.size,l.offset,(t=>{validateBufferIntegrity(f,l.integrity),n(t,o?f.toString(o):f)}))}}t.accessSync=function(e,r){const s=splitPath(e);if(!s.isAsar)return S.apply(this,arguments);const{asarPath:n,filePath:i}=s;null==r&&(r=t.constants.F_OK);const a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(o.unpacked){const e=a.copyFileOut(i);return t.accessSync(e,r)}if(!a.stat(i))throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(r&t.constants.W_OK)throw createError("NO_ACCESS",{asarPath:n,filePath:i})};const{readFile:D}=t;t.readFile=function(t,e,r){return splitPath(t).isAsar?fsReadFileAsar(t,e,r):D.apply(this,arguments)};const{readFile:R}=t.promises;function readFileFromArchiveSync(e,r){const{asarPath:n,filePath:i}=e,a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(0===o.size)return r?"":s.Buffer.alloc(0);if(o.unpacked){const e=a.copyFileOut(i);return t.readFileSync(e,r)}if(r){if("string"==typeof r)r={encoding:r};else if("object"!=typeof r)throw new TypeError("Bad arguments")}else r={encoding:null};const{encoding:c}=r,l=s.Buffer.alloc(o.size),f=a.getFdAndValidateIntegrityLater();if(!(f>=0))throw createError("NOT_FOUND",{asarPath:n,filePath:i});return logASARAccess(n,i,o.offset),t.readSync(f,l,0,o.size,o.offset),validateBufferIntegrity(l,o.integrity),c?l.toString(c):l}t.promises.readFile=function(t,e){if(!splitPath(t).isAsar)return R.apply(this,arguments);return a.promisify(fsReadFileAsar)(t,e)};const{readFileSync:T}=t;t.readFileSync=function(t,e){const r=splitPath(t);return r.isAsar?readFileFromArchiveSync(r,e):T.apply(this,arguments)};const processReaddirResult=t=>t.context.withFileTypes?function handleDirents({result:t,currentPath:e,context:r}){const s=t[0].length;for(let n=0;n<s;n++){const s=i.join(e,t[0][n]),a=splitPath(s);let o=t[1][n];if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)return;const e=t.stat(a.filePath);if(!e)continue;o=e.type}const c=_(e,t[0][n],o),l=u("fs").internalModuleStat(s);r.readdirResults.push(c),(c.isDirectory()||1===l)&&r.pathsQueue.push(i.join(c.path,c.name))}}(t):function handleFilePaths({result:t,currentPath:e,context:r}){for(let s=0;s<t.length;s++){const n=i.join(e,t[s]),a=i.relative(r.basePath,n),o=u("fs").internalModuleStat(n);r.readdirResults.push(a),1===o&&r.pathsQueue.push(n)}}(t);const{readdir:E}=t;t.readdir=function(e,r,s){if(F(s="function"==typeof r?r:s,"callback"),r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return void function readdirRecursive(t,e,r){const s={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};let n=0;!function read(t){const e=new h.FSReqCallback;e.oncomplete=(e,i)=>{e?r(e):void 0!==i?(processReaddirResult({result:i,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)):r(null,s.readdirResults)};const a=splitPath(t);if(a.isAsar){let e;const{asarPath:o,filePath:c}=a,l=getOrCreateArchive(o);if(!l){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(r,[t])}if(e=l.readdir(c),!e){const t=createError("NOT_FOUND",{asarPath:o,filePath:c});return void nextTick(r,[t])}s.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))]),processReaddirResult({result:e,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)}else h.readdir(t,s.encoding,s.withFileTypes,e)}(s.pathsQueue[n++])}(e,r,s);const n=splitPath(e);if(!n.isAsar)return E.apply(this,arguments);const{asarPath:a,filePath:o}=n,c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.readdir(o);if(l)if(r?.withFileTypes){const e=[];for(const r of l){const n=i.join(o,r),l=c.stat(n);if(!l){const t=createError("NOT_FOUND",{asarPath:a,filePath:n});return void nextTick(s,[t])}e.push(new t.Dirent(r,l.type))}nextTick(s,[null,e])}else nextTick(s,[null,l]);else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}};const{readdir:k}=t.promises;t.promises.readdir=async function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return async function readdirRecursivePromises(t,e){const r=[],s=splitPath(t);let n=[];const a=Boolean(e?.withFileTypes);let o=[];if(s.isAsar){const e=getOrCreateArchive(s.asarPath);if(!e)return r;const n=e.readdir(s.filePath);if(!n)return r;o=n,a&&(o=[[...o],o.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else o=await h.readdir(i.toNamespacedPath(t),e.encoding,a,b);if(n=[[t,o]],a)for(;n.length>0;){const{0:t,1:s}=n.pop();for(const a of getDirents(t,s))if(r.push(a),a.isDirectory()){const r=i.join(t,a.name),s=splitPath(r);let o;if(s.isAsar){const t=getOrCreateArchive(s.asarPath);if(!t)continue;const e=t.readdir(s.filePath);if(!e)continue;o=[[...e],e.map((t=>u("fs").internalModuleStat(i.join(r,t))))]}else o=await h.readdir(r,e.encoding,!0,b);n.push([r,o])}}else for(;n.length>0;){const{0:s,1:a}=n.pop();for(const o of a){const a=i.join(s,o),c=u("fs").internalModuleStat(a);if(r.push(i.relative(t,a)),1===c){const t=splitPath(a);let s=[];if(t.isAsar){const e=getOrCreateArchive(t.asarPath);if(!e)return;const n=e.readdir(t.filePath);if(!n)return r;s=n}else s=await h.readdir(i.toNamespacedPath(a),e.encoding,!1,b);n.push([a,s])}}}return r}(e,r);const s=splitPath(e);if(!s.isAsar)return k(e,r);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:n}));const c=o.readdir(a);if(!c)return l.reject(createError("NOT_FOUND",{asarPath:n,filePath:a}));if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return l.resolve(e)}return l.resolve(c)};const{readdirSync:V}=t;t.readdirSync=function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return function readdirSyncRecursive(t,e){const r={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};function read(t){let e;const s=splitPath(t);if(s.isAsar){const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return;if(e=o.readdir(a),!e)return;r.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else e=h.readdir(i.toNamespacedPath(t),r.encoding,r.withFileTypes);void 0!==e&&processReaddirResult({result:e,currentPath:t,context:r})}for(let t=0;t<r.pathsQueue.length;t++)read(r.pathsQueue[t]);return r.readdirResults}(e,r);const s=splitPath(e);if(!s.isAsar)return V.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.readdir(a);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return e}return c};u("modules").overrideReadFileSync((t=>{const e=splitPath(t);if(e.isAsar)try{return readFileFromArchiveSync(e,void 0)}catch{return!1}}));const{internalModuleStat:x}=h;u("fs").internalModuleStat=t=>{const e=splitPath(t);if(!e.isAsar)return x(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n)return-34;const i=n.stat(s);return i?i.type===w.kDirectory?1:0:-34};const{kUsePromises:b}=h;if("win32"===process.platform){const{mkdir:e}=t;t.mkdir=(t,r,s)=>{"function"==typeof r&&(s=r,r={});const n=splitPath(t);if(n.isAsar&&n.filePath.length>0){const t=createError("NOT_DIR");nextTick(s,[t])}else e(t,r,s)},t.promises.mkdir=a.promisify(t.mkdir);const{mkdirSync:r}=t;t.mkdirSync=function(t,e){const s=splitPath(t);if(s.isAsar&&s.filePath.length)throw createError("NOT_DIR");return r(t,e)}}function invokeWithNoAsar(t){return function(){const e=process.noAsar;process.noAsar=!0;try{return t.apply(this,arguments)}finally{process.noAsar=e}}}overrideAPI(t,"copyFile"),overrideAPISync(t,"copyFileSync"),overrideAPI(t,"open"),overrideAPISync(process,"dlopen",1),overrideAPISync(c._extensions,".node",1),overrideAPISync(t,"openSync");const overrideChildProcess=t=>{const{exec:e,execSync:r}=t;t.exec=invokeWithNoAsar(e),t.exec[a.promisify.custom]=A("exec",invokeWithNoAsar(e[a.promisify.custom])),t.execSync=invokeWithNoAsar(r),overrideAPI(t,"execFile"),overrideAPISync(t,"execFileSync")},C=new WeakSet;if(process.env.ELECTRON_EAGER_ASAR_HOOK_FOR_TESTING)overrideChildProcess(r("child_process"));else{const t=c._load;c._load=(e,...r)=>{const s=t(e,...r);if(("child_process"===e||"node:child_process"===e)&&!C.has(s)){C.add(s);overrideChildProcess(s)}return s}}}},buffer:t=>{t.exports=require("buffer")},child_process:t=>{t.exports=require("child_process")},crypto:t=>{t.exports=require("crypto")},fs:t=>{t.exports=require("fs")},module:t=>{t.exports=require("module")},os:t=>{t.exports=require("os")},path:t=>{t.exports=require("path")},util:t=>{t.exports=require("util")}},e={};function __webpack_require__(r){var s=e[r];if(void 0!==s)return s.exports;var n=e[r]={exports:{}};return t[r](n,n.exports,__webpack_require__),n.exports}var r={};(()=>{var t=r;Object.defineProperty(t,"__esModule",{value:!0});if((0,__webpack_require__("./lib/node/asar-fs-wrapper.ts").wrapFsWithAsar)(__webpack_require__("fs")),globalThis.blinkfetch){const t=["fetch","Response","FormData","Request","Headers","EventSource"];for(const e of t)globalThis[e]=globalThis[`blink${e}`]}const e=__webpack_require__("child_process"),s=e.fork;e.fork=(t,e,r)=>(null==e?e=[]:"object"!=typeof e||Array.isArray(e)||(r=e,e=[]),"string"!=typeof t||!Array.isArray(e)||"object"!=typeof r&&void 0!==r||((r=r??{}).env=Object.create(r.env||process.env),r.env.ELECTRON_RUN_AS_NODE="1",r.execPath||"darwin"!==process.platform||(r.execPath=process.helperExecPath)),s(t,e,r));const n=__webpack_require__("path"),i=__webpack_require__("module"),a=process.resourcesPath+n.sep,o=i._nodeModulePaths;i._nodeModulePaths=function(t){const e=o(t);return(n.resolve(t)+n.sep).startsWith(a)?e.filter((function(t){return t.startsWith(a)})):e}})()})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

Error: The specified module could not be found.
C:\Users\ygaba\source\repos\BPSR-Meter\node_modules\electron\dist\resources\build\Release\windivert.node
    at process.func [as dlopen] (node:electron/js2c/node_init:2:2617)
    at file:///C:/Users/ygaba/source/repos/BPSR-Meter/out/main/server.js:735:9
    at ModuleJob.run (node:internal/modules/esm/module_job:345:25)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:665:26)
    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:132:5) {
  code: 'ERR_DLOPEN_FAILED'
}

Node.js v22.20.0
[2025-10-25T01:38:53.805Z] SERVER PROCESS EXITED with code: 1, signal: null
[2025-10-25T01:38:53.805Z] SERVER PROCESS CLOSED with code: 1
[2025-10-25T01:39:00.116Z] All windows closed
[2025-10-25T01:39:00.117Z] Closing application (not macOS)
[2025-10-25T01:39:00.117Z] App closing, cleaning up processes...
[2025-10-25T01:40:16.875Z] ==== ELECTRON START ====
[2025-10-25T01:40:16.938Z] Electron app ready, starting createWindow()
[2025-10-25T01:40:16.939Z] === STARTING CREATEWINDOW ===
[2025-10-25T01:40:16.940Z] Node.js process: v22.20.0
[2025-10-25T01:40:16.940Z] Electron version: 38.3.0
[2025-10-25T01:40:16.941Z] Current directory: C:\Users\ygaba\source\repos\BPSR-Meter\out\main
[2025-10-25T01:40:16.941Z] Attempting to kill processes on port 8989...
[2025-10-25T01:40:17.000Z] Searching for available port starting from: 8989
[2025-10-25T01:40:17.001Z] Checking port availability: 8989
[2025-10-25T01:40:17.004Z] Port 8989 is available
[2025-10-25T01:40:17.004Z] Available port found: 8989
[2025-10-25T01:40:17.064Z] User data path: C:\Users\ygaba\AppData\Roaming\bpsr-meter
[2025-10-25T01:40:17.064Z] Launching server.js on port 8989 with path: C:\Users\ygaba\source\repos\BPSR-Meter\out\main\server.js
[2025-10-25T01:40:17.462Z] SERVER STDERR: node:electron/js2c/node_init:2
(()=>{"use strict";var t={"./lib/node/asar-fs-wrapper.ts":(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.wrapFsWithAsar=void 0;const s=r("buffer"),n=r("fs"),i=r("path"),a=r("util"),o=process._linkedBinding("electron_common_asar"),c=r("module"),l=global.Promise,f=process.env.ELECTRON_NO_ASAR&&"browser"!==process.type&&"renderer"!==process.type,u=process.internalBinding;delete process.internalBinding;const nextTick=(t,e=[])=>{process.nextTick((()=>t(...e)))},h=u("fs"),p=new Map,getOrCreateArchive=t=>{if(p.has(t))return p.get(t);try{const e=new o.Archive(t);return p.set(t,e),e}catch{return null}};process._getOrCreateArchive=getOrCreateArchive;const d=/\.asar/i,{getValidatedPath:y,getOptions:P,getDirent:_}=require("internal/fs/utils"),{assignFunctionName:A}=require("internal/util"),{validateBoolean:N,validateFunction:F}=require("internal/validators"),{URL:I}=require("internal/url"),splitPath=t=>{if(process.noAsar||f)return{isAsar:!1};let e=t;return s.Buffer.isBuffer(t)&&(e=t.toString()),e instanceof I&&(e=y(e)),"string"!=typeof e?{isAsar:!1}:d.test(e)?o.splitPath(i.normalize(e)):{isAsar:!1}};let v=0;const O=process.getuid?.()??0,g=process.getgid?.()??0,m=new Date;function getDirents(t,{0:e,1:r}){for(let s=0;s<e.length;s++){let n=r[s];const a=splitPath(i.join(t,e[s]));if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)continue;const e=t.stat(a.filePath);if(!e)continue;n=e.type}e[s]=_(t,e[s],n)}return e}var w;!function(t){t[t.kFile=n.constants.UV_DIRENT_FILE]="kFile",t[t.kDirectory=n.constants.UV_DIRENT_DIR]="kDirectory",t[t.kLink=n.constants.UV_DIRENT_LINK]="kLink"}(w||(w={}));const S=new Map([[w.kFile,n.constants.S_IFREG],[w.kDirectory,n.constants.S_IFDIR],[w.kLink,n.constants.S_IFLNK]]),asarStatsToFsStats=function(t){const{Stats:e}=r("fs");return new e(1,n.constants.S_IROTH|n.constants.S_IRGRP|n.constants.S_IRUSR|n.constants.S_IWUSR|S.get(t.type),1,O,g,0,void 0,++v,t.size,void 0,m.getTime(),m.getTime(),m.getTime(),m.getTime())},createError=(t,{asarPath:e,filePath:r}={})=>{let s;switch(t){case"NOT_FOUND":s=new Error(`ENOENT, ${r} not found in ${e}`),s.code="ENOENT",s.errno=-2;break;case"NOT_DIR":s=new Error("ENOTDIR, not a directory"),s.code="ENOTDIR",s.errno=-20;break;case"NO_ACCESS":s=new Error(`EACCES: permission denied, access '${r}'`),s.code="EACCES",s.errno=-13;break;case"INVALID_ARCHIVE":s=new Error(`Invalid package ${e}`);break;default:throw new Error(`Invalid error type "${t}" passed to createError.`)}return s},overrideAPISync=function(t,e,r,s=!1){null==r&&(r=0);const n=t[e],func=function(...t){const e=t[r],s=splitPath(e);if(!s.isAsar)return n.apply(this,t);const{asarPath:i,filePath:a}=s,o=getOrCreateArchive(i);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:i});const c=o.copyFileOut(a);if(!c)throw createError("NOT_FOUND",{asarPath:i,filePath:a});return t[r]=c,n.apply(this,t)};if(s)return func;t[e]=func},overrideAPI=function(t,e,r){null==r&&(r=0);const s=t[e];t[e]=function(...n){const i=n[r],a=splitPath(i);if(!a.isAsar)return s.apply(this,n);const{asarPath:o,filePath:c}=a,l=n[n.length-1];if("function"!=typeof l)return overrideAPISync(t,e,r,!0).apply(this,n);const f=getOrCreateArchive(o);if(!f){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(l,[t])}const u=f.copyFileOut(c);if(u)return n[r]=u,s.apply(this,n);{const t=createError("NOT_FOUND",{asarPath:o,filePath:c});nextTick(l,[t])}},s[a.promisify.custom]&&(t[e][a.promisify.custom]=A(e,makePromiseFunction(s[a.promisify.custom],r))),t.promises&&t.promises[e]&&(t.promises[e]=makePromiseFunction(t.promises[e],r))};let D;function validateBufferIntegrity(t,e){if(!e)return;D=D||r("crypto");const s=D.createHash(e.algorithm).update(t).digest("hex");s!==e.hash&&(console.error(`ASAR Integrity Violation: got a hash mismatch (${s} vs ${e.hash})`),process.exit(1))}const makePromiseFunction=function(t,e){return function(...r){const s=r[e],n=splitPath(s);if(!n.isAsar)return t.apply(this,r);const{asarPath:i,filePath:a}=n,o=getOrCreateArchive(i);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:i}));const c=o.copyFileOut(a);return c?(r[e]=c,t.apply(this,r)):l.reject(createError("NOT_FOUND",{asarPath:i,filePath:a}))}};e.wrapFsWithAsar=t=>{const e=new Map,logASARAccess=(s,n,a)=>{if(process.env.ELECTRON_LOG_ASAR_READS){if(!e.has(s)){const n=`${i.basename(s,".asar")}-access-log.txt`,a=i.join(r("os").tmpdir(),n);e.set(s,t.openSync(a,"a"))}t.writeSync(e.get(s),`${a}: ${n}\n`)}},shouldThrowStatError=t=>!t||"object"!=typeof t||!1!==t.throwIfNoEntry,{lstatSync:n}=t;t.lstatSync=(t,e)=>{const r=splitPath(t);if(!r.isAsar)return n(t,e);const{asarPath:s,filePath:i}=r,a=getOrCreateArchive(s);if(!a){if(shouldThrowStatError(e))throw createError("INVALID_ARCHIVE",{asarPath:s});return null}const o=a.stat(i);if(!o){if(shouldThrowStatError(e))throw createError("NOT_FOUND",{asarPath:s,filePath:i});return null}return asarStatsToFsStats(o)};const{lstat:o}=t;t.lstat=(t,e,r)=>{const s=splitPath(t);if("function"==typeof e&&(r=e,e={}),!s.isAsar)return o(t,e,r);const{asarPath:n,filePath:i}=s,a=getOrCreateArchive(n);if(!a){const t=createError("INVALID_ARCHIVE",{asarPath:n});return void nextTick(r,[t])}const c=a.stat(i);if(!c){const t=createError("NOT_FOUND",{asarPath:n,filePath:i});return void nextTick(r,[t])}const l=asarStatsToFsStats(c);nextTick(r,[null,l])},t.promises.lstat=a.promisify(t.lstat);const{statSync:f}=t;t.statSync=(e,r)=>{const{isAsar:s}=splitPath(e);return s?t.lstatSync(e,r):f(e,r)};const{stat:p}=t;t.stat=(e,r,s)=>{const{isAsar:n}=splitPath(e);if("function"==typeof r&&(s=r,r={}),!n)return p(e,r,s);process.nextTick((()=>t.lstat(e,r,s)))},t.promises.stat=a.promisify(t.stat);const wrapRealpathSync=function(t){return function(e,r){const s=splitPath(e);if(!s.isAsar)return t.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.realpath(a);if(!1===c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});return i.join(t(n,r),c)}},{realpathSync:d}=t;t.realpathSync=wrapRealpathSync(d),t.realpathSync.native=wrapRealpathSync(d.native);const wrapRealpath=function(t){return function(e,r,s){const n=splitPath(e);if(!n.isAsar)return t.apply(this,arguments);const{asarPath:a,filePath:o}=n;arguments.length<3&&(s=r,r={});const c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.realpath(o);if(!1!==l)t(a,r,((t,e)=>{if(null===t){const t=i.join(e,l);s(null,t)}else s(t)}));else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}}},{realpath:I}=t;t.realpath=wrapRealpath(I),t.realpath.native=wrapRealpath(I.native),t.promises.realpath=a.promisify(t.realpath.native);const{exists:v}=t;t.exists=function exists(t,e){let r;try{r=splitPath(t)}catch{return void nextTick(e,[!1])}if(!r.isAsar)return v(t,e);const{asarPath:s,filePath:n}=r,i=getOrCreateArchive(s);if(!i){const t=createError("INVALID_ARCHIVE",{asarPath:s});return void nextTick(e,[t])}const a=!1!==i.stat(n);nextTick(e,[a])},t.exists[a.promisify.custom]=function exists(t){const e=splitPath(t);if(!e.isAsar)return v[a.promisify.custom](t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n){const t=createError("INVALID_ARCHIVE",{asarPath:r});return l.reject(t)}return l.resolve(!1!==n.stat(s))};const{existsSync:O}=t;t.existsSync=t=>{let e;try{e=splitPath(t)}catch{return!1}if(!e.isAsar)return O(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);return!!n&&!1!==n.stat(s)};const{access:g}=t;t.access=function(e,r,s){const n=splitPath(e);if(!n.isAsar)return g.apply(this,arguments);const{asarPath:i,filePath:a}=n;"function"==typeof r&&(s=r,r=t.constants.F_OK);const o=getOrCreateArchive(i);if(!o){const t=createError("INVALID_ARCHIVE",{asarPath:i});return void nextTick(s,[t])}const c=o.getFileInfo(a);if(!c){const t=createError("NOT_FOUND",{asarPath:i,filePath:a});return void nextTick(s,[t])}if(c.unpacked){const e=o.copyFileOut(a);return t.access(e,r,s)}if(o.stat(a))if(r&t.constants.W_OK){const t=createError("NO_ACCESS",{asarPath:i,filePath:a});nextTick(s,[t])}else nextTick(s);else{const t=createError("NOT_FOUND",{asarPath:i,filePath:a});nextTick(s,[t])}};const{access:m}=t.promises;t.promises.access=function(e,r){if(!splitPath(e).isAsar)return m.apply(this,arguments);return a.promisify(t.access)(e,r)};const{accessSync:S}=t;function fsReadFileAsar(e,r,n){const i=splitPath(e);if(i.isAsar){const{asarPath:e,filePath:a}=i;if("function"==typeof r)n=r,r={encoding:null};else if("string"==typeof r)r={encoding:r};else if(null==r)r={encoding:null};else if("object"!=typeof r)throw new TypeError("Bad arguments");const{encoding:o}=r,c=getOrCreateArchive(e);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:e});return void nextTick(n,[t])}const l=c.getFileInfo(a);if(!l){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}if(0===l.size)return void nextTick(n,[null,o?"":s.Buffer.alloc(0)]);if(l.unpacked){const e=c.copyFileOut(a);return t.readFile(e,r,n)}const f=s.Buffer.alloc(l.size),u=c.getFdAndValidateIntegrityLater();if(!(u>=0)){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}logASARAccess(e,a,l.offset),t.read(u,f,0,l.size,l.offset,(t=>{validateBufferIntegrity(f,l.integrity),n(t,o?f.toString(o):f)}))}}t.accessSync=function(e,r){const s=splitPath(e);if(!s.isAsar)return S.apply(this,arguments);const{asarPath:n,filePath:i}=s;null==r&&(r=t.constants.F_OK);const a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(o.unpacked){const e=a.copyFileOut(i);return t.accessSync(e,r)}if(!a.stat(i))throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(r&t.constants.W_OK)throw createError("NO_ACCESS",{asarPath:n,filePath:i})};const{readFile:D}=t;t.readFile=function(t,e,r){return splitPath(t).isAsar?fsReadFileAsar(t,e,r):D.apply(this,arguments)};const{readFile:R}=t.promises;function readFileFromArchiveSync(e,r){const{asarPath:n,filePath:i}=e,a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(0===o.size)return r?"":s.Buffer.alloc(0);if(o.unpacked){const e=a.copyFileOut(i);return t.readFileSync(e,r)}if(r){if("string"==typeof r)r={encoding:r};else if("object"!=typeof r)throw new TypeError("Bad arguments")}else r={encoding:null};const{encoding:c}=r,l=s.Buffer.alloc(o.size),f=a.getFdAndValidateIntegrityLater();if(!(f>=0))throw createError("NOT_FOUND",{asarPath:n,filePath:i});return logASARAccess(n,i,o.offset),t.readSync(f,l,0,o.size,o.offset),validateBufferIntegrity(l,o.integrity),c?l.toString(c):l}t.promises.readFile=function(t,e){if(!splitPath(t).isAsar)return R.apply(this,arguments);return a.promisify(fsReadFileAsar)(t,e)};const{readFileSync:T}=t;t.readFileSync=function(t,e){const r=splitPath(t);return r.isAsar?readFileFromArchiveSync(r,e):T.apply(this,arguments)};const processReaddirResult=t=>t.context.withFileTypes?function handleDirents({result:t,currentPath:e,context:r}){const s=t[0].length;for(let n=0;n<s;n++){const s=i.join(e,t[0][n]),a=splitPath(s);let o=t[1][n];if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)return;const e=t.stat(a.filePath);if(!e)continue;o=e.type}const c=_(e,t[0][n],o),l=u("fs").internalModuleStat(s);r.readdirResults.push(c),(c.isDirectory()||1===l)&&r.pathsQueue.push(i.join(c.path,c.name))}}(t):function handleFilePaths({result:t,currentPath:e,context:r}){for(let s=0;s<t.length;s++){const n=i.join(e,t[s]),a=i.relative(r.basePath,n),o=u("fs").internalModuleStat(n);r.readdirResults.push(a),1===o&&r.pathsQueue.push(n)}}(t);const{readdir:E}=t;t.readdir=function(e,r,s){if(F(s="function"==typeof r?r:s,"callback"),r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return void function readdirRecursive(t,e,r){const s={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};let n=0;!function read(t){const e=new h.FSReqCallback;e.oncomplete=(e,i)=>{e?r(e):void 0!==i?(processReaddirResult({result:i,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)):r(null,s.readdirResults)};const a=splitPath(t);if(a.isAsar){let e;const{asarPath:o,filePath:c}=a,l=getOrCreateArchive(o);if(!l){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(r,[t])}if(e=l.readdir(c),!e){const t=createError("NOT_FOUND",{asarPath:o,filePath:c});return void nextTick(r,[t])}s.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))]),processReaddirResult({result:e,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)}else h.readdir(t,s.encoding,s.withFileTypes,e)}(s.pathsQueue[n++])}(e,r,s);const n=splitPath(e);if(!n.isAsar)return E.apply(this,arguments);const{asarPath:a,filePath:o}=n,c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.readdir(o);if(l)if(r?.withFileTypes){const e=[];for(const r of l){const n=i.join(o,r),l=c.stat(n);if(!l){const t=createError("NOT_FOUND",{asarPath:a,filePath:n});return void nextTick(s,[t])}e.push(new t.Dirent(r,l.type))}nextTick(s,[null,e])}else nextTick(s,[null,l]);else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}};const{readdir:k}=t.promises;t.promises.readdir=async function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return async function readdirRecursivePromises(t,e){const r=[],s=splitPath(t);let n=[];const a=Boolean(e?.withFileTypes);let o=[];if(s.isAsar){const e=getOrCreateArchive(s.asarPath);if(!e)return r;const n=e.readdir(s.filePath);if(!n)return r;o=n,a&&(o=[[...o],o.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else o=await h.readdir(i.toNamespacedPath(t),e.encoding,a,b);if(n=[[t,o]],a)for(;n.length>0;){const{0:t,1:s}=n.pop();for(const a of getDirents(t,s))if(r.push(a),a.isDirectory()){const r=i.join(t,a.name),s=splitPath(r);let o;if(s.isAsar){const t=getOrCreateArchive(s.asarPath);if(!t)continue;const e=t.readdir(s.filePath);if(!e)continue;o=[[...e],e.map((t=>u("fs").internalModuleStat(i.join(r,t))))]}else o=await h.readdir(r,e.encoding,!0,b);n.push([r,o])}}else for(;n.length>0;){const{0:s,1:a}=n.pop();for(const o of a){const a=i.join(s,o),c=u("fs").internalModuleStat(a);if(r.push(i.relative(t,a)),1===c){const t=splitPath(a);let s=[];if(t.isAsar){const e=getOrCreateArchive(t.asarPath);if(!e)return;const n=e.readdir(t.filePath);if(!n)return r;s=n}else s=await h.readdir(i.toNamespacedPath(a),e.encoding,!1,b);n.push([a,s])}}}return r}(e,r);const s=splitPath(e);if(!s.isAsar)return k(e,r);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:n}));const c=o.readdir(a);if(!c)return l.reject(createError("NOT_FOUND",{asarPath:n,filePath:a}));if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return l.resolve(e)}return l.resolve(c)};const{readdirSync:V}=t;t.readdirSync=function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return function readdirSyncRecursive(t,e){const r={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};function read(t){let e;const s=splitPath(t);if(s.isAsar){const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return;if(e=o.readdir(a),!e)return;r.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else e=h.readdir(i.toNamespacedPath(t),r.encoding,r.withFileTypes);void 0!==e&&processReaddirResult({result:e,currentPath:t,context:r})}for(let t=0;t<r.pathsQueue.length;t++)read(r.pathsQueue[t]);return r.readdirResults}(e,r);const s=splitPath(e);if(!s.isAsar)return V.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.readdir(a);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return e}return c};u("modules").overrideReadFileSync((t=>{const e=splitPath(t);if(e.isAsar)try{return readFileFromArchiveSync(e,void 0)}catch{return!1}}));const{internalModuleStat:x}=h;u("fs").internalModuleStat=t=>{const e=splitPath(t);if(!e.isAsar)return x(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n)return-34;const i=n.stat(s);return i?i.type===w.kDirectory?1:0:-34};const{kUsePromises:b}=h;if("win32"===process.platform){const{mkdir:e}=t;t.mkdir=(t,r,s)=>{"function"==typeof r&&(s=r,r={});const n=splitPath(t);if(n.isAsar&&n.filePath.length>0){const t=createError("NOT_DIR");nextTick(s,[t])}else e(t,r,s)},t.promises.mkdir=a.promisify(t.mkdir);const{mkdirSync:r}=t;t.mkdirSync=function(t,e){const s=splitPath(t);if(s.isAsar&&s.filePath.length)throw createError("NOT_DIR");return r(t,e)}}function invokeWithNoAsar(t){return function(){const e=process.noAsar;process.noAsar=!0;try{return t.apply(this,arguments)}finally{process.noAsar=e}}}overrideAPI(t,"copyFile"),overrideAPISync(t,"copyFileSync"),overrideAPI(t,"open"),overrideAPISync(process,"dlopen",1),overrideAPISync(c._extensions,".node",1),overrideAPISync(t,"openSync");const overrideChildProcess=t=>{const{exec:e,execSync:r}=t;t.exec=invokeWithNoAsar(e),t.exec[a.promisify.custom]=A("exec",invokeWithNoAsar(e[a.promisify.custom])),t.execSync=invokeWithNoAsar(r),overrideAPI(t,"execFile"),overrideAPISync(t,"execFileSync")},C=new WeakSet;if(process.env.ELECTRON_EAGER_ASAR_HOOK_FOR_TESTING)overrideChildProcess(r("child_process"));else{const t=c._load;c._load=(e,...r)=>{const s=t(e,...r);if(("child_process"===e||"node:child_process"===e)&&!C.has(s)){C.add(s);overrideChildProcess(s)}return s}}}},buffer:t=>{t.exports=require("buffer")},child_process:t=>{t.exports=require("child_process")},crypto:t=>{t.exports=require("crypto")},fs:t=>{t.exports=require("fs")},module:t=>{t.exports=require("module")},os:t=>{t.exports=require("os")},path:t=>{t.exports=require("path")},util:t=>{t.exports=require("util")}},e={};function __webpack_require__(r){var s=e[r];if(void 0!==s)return s.exports;var n=e[r]={exports:{}};return t[r](n,n.exports,__webpack_require__),n.exports}var r={};(()=>{var t=r;Object.defineProperty(t,"__esModule",{value:!0});if((0,__webpack_require__("./lib/node/asar-fs-wrapper.ts").wrapFsWithAsar)(__webpack_require__("fs")),globalThis.blinkfetch){const t=["fetch","Response","FormData","Request","Headers","EventSource"];for(const e of t)globalThis[e]=globalThis[`blink${e}`]}const e=__webpack_require__("child_process"),s=e.fork;e.fork=(t,e,r)=>(null==e?e=[]:"object"!=typeof e||Array.isArray(e)||(r=e,e=[]),"string"!=typeof t||!Array.isArray(e)||"object"!=typeof r&&void 0!==r||((r=r??{}).env=Object.create(r.env||process.env),r.env.ELECTRON_RUN_AS_NODE="1",r.execPath||"darwin"!==process.platform||(r.execPath=process.helperExecPath)),s(t,e,r));const n=__webpack_require__("path"),i=__webpack_require__("module"),a=process.resourcesPath+n.sep,o=i._nodeModulePaths;i._nodeModulePaths=function(t){const e=o(t);return(n.resolve(t)+n.sep).startsWith(a)?e.filter((function(t){return t.startsWith(a)})):e}})()})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

Error: The specified module could not be found.
C:\Users\ygaba\source\repos\BPSR-Meter\node_modules\electron\dist\resources\build\Release\windivert.node
    at process.func [as dlopen] (node:electron/js2c/node_init:2:2617)
    at file:///C:/Users/ygaba/source/repos/BPSR-Meter/out/main/server.js:735:9
    at ModuleJob.run (node:internal/modules/esm/module_job:345:25)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:665:26)
    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:132:5) {
  code: 'ERR_DLOPEN_FAILED'
}

Node.js v22.20.0
[2025-10-25T01:40:17.472Z] SERVER PROCESS EXITED with code: 1, signal: null
[2025-10-25T01:40:17.473Z] SERVER PROCESS CLOSED with code: 1
[2025-10-25T01:40:21.672Z] All windows closed
[2025-10-25T01:40:21.673Z] Closing application (not macOS)
[2025-10-25T01:40:21.673Z] App closing, cleaning up processes...
[2025-10-25T01:40:55.545Z] ==== ELECTRON START ====
[2025-10-25T01:40:55.616Z] Electron app ready, starting createWindow()
[2025-10-25T01:40:55.617Z] === STARTING CREATEWINDOW ===
[2025-10-25T01:40:55.618Z] Node.js process: v22.20.0
[2025-10-25T01:40:55.619Z] Electron version: 38.3.0
[2025-10-25T01:40:55.619Z] Current directory: C:\Users\ygaba\source\repos\BPSR-Meter\out\main
[2025-10-25T01:40:55.620Z] Attempting to kill processes on port 8989...
[2025-10-25T01:40:55.677Z] Searching for available port starting from: 8989
[2025-10-25T01:40:55.678Z] Checking port availability: 8989
[2025-10-25T01:40:55.681Z] Port 8989 is available
[2025-10-25T01:40:55.681Z] Available port found: 8989
[2025-10-25T01:40:55.743Z] User data path: C:\Users\ygaba\AppData\Roaming\bpsr-meter
[2025-10-25T01:40:55.744Z] Launching server.js on port 8989 with path: C:\Users\ygaba\source\repos\BPSR-Meter\out\main\server.js
[2025-10-25T01:40:56.072Z] SERVER STDERR: node:electron/js2c/node_init:2
(()=>{"use strict";var t={"./lib/node/asar-fs-wrapper.ts":(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.wrapFsWithAsar=void 0;const s=r("buffer"),n=r("fs"),i=r("path"),a=r("util"),o=process._linkedBinding("electron_common_asar"),c=r("module"),l=global.Promise,f=process.env.ELECTRON_NO_ASAR&&"browser"!==process.type&&"renderer"!==process.type,u=process.internalBinding;delete process.internalBinding;const nextTick=(t,e=[])=>{process.nextTick((()=>t(...e)))},h=u("fs"),p=new Map,getOrCreateArchive=t=>{if(p.has(t))return p.get(t);try{const e=new o.Archive(t);return p.set(t,e),e}catch{return null}};process._getOrCreateArchive=getOrCreateArchive;const d=/\.asar/i,{getValidatedPath:y,getOptions:P,getDirent:_}=require("internal/fs/utils"),{assignFunctionName:A}=require("internal/util"),{validateBoolean:N,validateFunction:F}=require("internal/validators"),{URL:I}=require("internal/url"),splitPath=t=>{if(process.noAsar||f)return{isAsar:!1};let e=t;return s.Buffer.isBuffer(t)&&(e=t.toString()),e instanceof I&&(e=y(e)),"string"!=typeof e?{isAsar:!1}:d.test(e)?o.splitPath(i.normalize(e)):{isAsar:!1}};let v=0;const O=process.getuid?.()??0,g=process.getgid?.()??0,m=new Date;function getDirents(t,{0:e,1:r}){for(let s=0;s<e.length;s++){let n=r[s];const a=splitPath(i.join(t,e[s]));if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)continue;const e=t.stat(a.filePath);if(!e)continue;n=e.type}e[s]=_(t,e[s],n)}return e}var w;!function(t){t[t.kFile=n.constants.UV_DIRENT_FILE]="kFile",t[t.kDirectory=n.constants.UV_DIRENT_DIR]="kDirectory",t[t.kLink=n.constants.UV_DIRENT_LINK]="kLink"}(w||(w={}));const S=new Map([[w.kFile,n.constants.S_IFREG],[w.kDirectory,n.constants.S_IFDIR],[w.kLink,n.constants.S_IFLNK]]),asarStatsToFsStats=function(t){const{Stats:e}=r("fs");return new e(1,n.constants.S_IROTH|n.constants.S_IRGRP|n.constants.S_IRUSR|n.constants.S_IWUSR|S.get(t.type),1,O,g,0,void 0,++v,t.size,void 0,m.getTime(),m.getTime(),m.getTime(),m.getTime())},createError=(t,{asarPath:e,filePath:r}={})=>{let s;switch(t){case"NOT_FOUND":s=new Error(`ENOENT, ${r} not found in ${e}`),s.code="ENOENT",s.errno=-2;break;case"NOT_DIR":s=new Error("ENOTDIR, not a directory"),s.code="ENOTDIR",s.errno=-20;break;case"NO_ACCESS":s=new Error(`EACCES: permission denied, access '${r}'`),s.code="EACCES",s.errno=-13;break;case"INVALID_ARCHIVE":s=new Error(`Invalid package ${e}`);break;default:throw new Error(`Invalid error type "${t}" passed to createError.`)}return s},overrideAPISync=function(t,e,r,s=!1){null==r&&(r=0);const n=t[e],func=function(...t){const e=t[r],s=splitPath(e);if(!s.isAsar)return n.apply(this,t);const{asarPath:i,filePath:a}=s,o=getOrCreateArchive(i);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:i});const c=o.copyFileOut(a);if(!c)throw createError("NOT_FOUND",{asarPath:i,filePath:a});return t[r]=c,n.apply(this,t)};if(s)return func;t[e]=func},overrideAPI=function(t,e,r){null==r&&(r=0);const s=t[e];t[e]=function(...n){const i=n[r],a=splitPath(i);if(!a.isAsar)return s.apply(this,n);const{asarPath:o,filePath:c}=a,l=n[n.length-1];if("function"!=typeof l)return overrideAPISync(t,e,r,!0).apply(this,n);const f=getOrCreateArchive(o);if(!f){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(l,[t])}const u=f.copyFileOut(c);if(u)return n[r]=u,s.apply(this,n);{const t=createError("NOT_FOUND",{asarPath:o,filePath:c});nextTick(l,[t])}},s[a.promisify.custom]&&(t[e][a.promisify.custom]=A(e,makePromiseFunction(s[a.promisify.custom],r))),t.promises&&t.promises[e]&&(t.promises[e]=makePromiseFunction(t.promises[e],r))};let D;function validateBufferIntegrity(t,e){if(!e)return;D=D||r("crypto");const s=D.createHash(e.algorithm).update(t).digest("hex");s!==e.hash&&(console.error(`ASAR Integrity Violation: got a hash mismatch (${s} vs ${e.hash})`),process.exit(1))}const makePromiseFunction=function(t,e){return function(...r){const s=r[e],n=splitPath(s);if(!n.isAsar)return t.apply(this,r);const{asarPath:i,filePath:a}=n,o=getOrCreateArchive(i);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:i}));const c=o.copyFileOut(a);return c?(r[e]=c,t.apply(this,r)):l.reject(createError("NOT_FOUND",{asarPath:i,filePath:a}))}};e.wrapFsWithAsar=t=>{const e=new Map,logASARAccess=(s,n,a)=>{if(process.env.ELECTRON_LOG_ASAR_READS){if(!e.has(s)){const n=`${i.basename(s,".asar")}-access-log.txt`,a=i.join(r("os").tmpdir(),n);e.set(s,t.openSync(a,"a"))}t.writeSync(e.get(s),`${a}: ${n}\n`)}},shouldThrowStatError=t=>!t||"object"!=typeof t||!1!==t.throwIfNoEntry,{lstatSync:n}=t;t.lstatSync=(t,e)=>{const r=splitPath(t);if(!r.isAsar)return n(t,e);const{asarPath:s,filePath:i}=r,a=getOrCreateArchive(s);if(!a){if(shouldThrowStatError(e))throw createError("INVALID_ARCHIVE",{asarPath:s});return null}const o=a.stat(i);if(!o){if(shouldThrowStatError(e))throw createError("NOT_FOUND",{asarPath:s,filePath:i});return null}return asarStatsToFsStats(o)};const{lstat:o}=t;t.lstat=(t,e,r)=>{const s=splitPath(t);if("function"==typeof e&&(r=e,e={}),!s.isAsar)return o(t,e,r);const{asarPath:n,filePath:i}=s,a=getOrCreateArchive(n);if(!a){const t=createError("INVALID_ARCHIVE",{asarPath:n});return void nextTick(r,[t])}const c=a.stat(i);if(!c){const t=createError("NOT_FOUND",{asarPath:n,filePath:i});return void nextTick(r,[t])}const l=asarStatsToFsStats(c);nextTick(r,[null,l])},t.promises.lstat=a.promisify(t.lstat);const{statSync:f}=t;t.statSync=(e,r)=>{const{isAsar:s}=splitPath(e);return s?t.lstatSync(e,r):f(e,r)};const{stat:p}=t;t.stat=(e,r,s)=>{const{isAsar:n}=splitPath(e);if("function"==typeof r&&(s=r,r={}),!n)return p(e,r,s);process.nextTick((()=>t.lstat(e,r,s)))},t.promises.stat=a.promisify(t.stat);const wrapRealpathSync=function(t){return function(e,r){const s=splitPath(e);if(!s.isAsar)return t.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.realpath(a);if(!1===c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});return i.join(t(n,r),c)}},{realpathSync:d}=t;t.realpathSync=wrapRealpathSync(d),t.realpathSync.native=wrapRealpathSync(d.native);const wrapRealpath=function(t){return function(e,r,s){const n=splitPath(e);if(!n.isAsar)return t.apply(this,arguments);const{asarPath:a,filePath:o}=n;arguments.length<3&&(s=r,r={});const c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.realpath(o);if(!1!==l)t(a,r,((t,e)=>{if(null===t){const t=i.join(e,l);s(null,t)}else s(t)}));else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}}},{realpath:I}=t;t.realpath=wrapRealpath(I),t.realpath.native=wrapRealpath(I.native),t.promises.realpath=a.promisify(t.realpath.native);const{exists:v}=t;t.exists=function exists(t,e){let r;try{r=splitPath(t)}catch{return void nextTick(e,[!1])}if(!r.isAsar)return v(t,e);const{asarPath:s,filePath:n}=r,i=getOrCreateArchive(s);if(!i){const t=createError("INVALID_ARCHIVE",{asarPath:s});return void nextTick(e,[t])}const a=!1!==i.stat(n);nextTick(e,[a])},t.exists[a.promisify.custom]=function exists(t){const e=splitPath(t);if(!e.isAsar)return v[a.promisify.custom](t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n){const t=createError("INVALID_ARCHIVE",{asarPath:r});return l.reject(t)}return l.resolve(!1!==n.stat(s))};const{existsSync:O}=t;t.existsSync=t=>{let e;try{e=splitPath(t)}catch{return!1}if(!e.isAsar)return O(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);return!!n&&!1!==n.stat(s)};const{access:g}=t;t.access=function(e,r,s){const n=splitPath(e);if(!n.isAsar)return g.apply(this,arguments);const{asarPath:i,filePath:a}=n;"function"==typeof r&&(s=r,r=t.constants.F_OK);const o=getOrCreateArchive(i);if(!o){const t=createError("INVALID_ARCHIVE",{asarPath:i});return void nextTick(s,[t])}const c=o.getFileInfo(a);if(!c){const t=createError("NOT_FOUND",{asarPath:i,filePath:a});return void nextTick(s,[t])}if(c.unpacked){const e=o.copyFileOut(a);return t.access(e,r,s)}if(o.stat(a))if(r&t.constants.W_OK){const t=createError("NO_ACCESS",{asarPath:i,filePath:a});nextTick(s,[t])}else nextTick(s);else{const t=createError("NOT_FOUND",{asarPath:i,filePath:a});nextTick(s,[t])}};const{access:m}=t.promises;t.promises.access=function(e,r){if(!splitPath(e).isAsar)return m.apply(this,arguments);return a.promisify(t.access)(e,r)};const{accessSync:S}=t;function fsReadFileAsar(e,r,n){const i=splitPath(e);if(i.isAsar){const{asarPath:e,filePath:a}=i;if("function"==typeof r)n=r,r={encoding:null};else if("string"==typeof r)r={encoding:r};else if(null==r)r={encoding:null};else if("object"!=typeof r)throw new TypeError("Bad arguments");const{encoding:o}=r,c=getOrCreateArchive(e);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:e});return void nextTick(n,[t])}const l=c.getFileInfo(a);if(!l){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}if(0===l.size)return void nextTick(n,[null,o?"":s.Buffer.alloc(0)]);if(l.unpacked){const e=c.copyFileOut(a);return t.readFile(e,r,n)}const f=s.Buffer.alloc(l.size),u=c.getFdAndValidateIntegrityLater();if(!(u>=0)){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}logASARAccess(e,a,l.offset),t.read(u,f,0,l.size,l.offset,(t=>{validateBufferIntegrity(f,l.integrity),n(t,o?f.toString(o):f)}))}}t.accessSync=function(e,r){const s=splitPath(e);if(!s.isAsar)return S.apply(this,arguments);const{asarPath:n,filePath:i}=s;null==r&&(r=t.constants.F_OK);const a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(o.unpacked){const e=a.copyFileOut(i);return t.accessSync(e,r)}if(!a.stat(i))throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(r&t.constants.W_OK)throw createError("NO_ACCESS",{asarPath:n,filePath:i})};const{readFile:D}=t;t.readFile=function(t,e,r){return splitPath(t).isAsar?fsReadFileAsar(t,e,r):D.apply(this,arguments)};const{readFile:R}=t.promises;function readFileFromArchiveSync(e,r){const{asarPath:n,filePath:i}=e,a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(0===o.size)return r?"":s.Buffer.alloc(0);if(o.unpacked){const e=a.copyFileOut(i);return t.readFileSync(e,r)}if(r){if("string"==typeof r)r={encoding:r};else if("object"!=typeof r)throw new TypeError("Bad arguments")}else r={encoding:null};const{encoding:c}=r,l=s.Buffer.alloc(o.size),f=a.getFdAndValidateIntegrityLater();if(!(f>=0))throw createError("NOT_FOUND",{asarPath:n,filePath:i});return logASARAccess(n,i,o.offset),t.readSync(f,l,0,o.size,o.offset),validateBufferIntegrity(l,o.integrity),c?l.toString(c):l}t.promises.readFile=function(t,e){if(!splitPath(t).isAsar)return R.apply(this,arguments);return a.promisify(fsReadFileAsar)(t,e)};const{readFileSync:T}=t;t.readFileSync=function(t,e){const r=splitPath(t);return r.isAsar?readFileFromArchiveSync(r,e):T.apply(this,arguments)};const processReaddirResult=t=>t.context.withFileTypes?function handleDirents({result:t,currentPath:e,context:r}){const s=t[0].length;for(let n=0;n<s;n++){const s=i.join(e,t[0][n]),a=splitPath(s);let o=t[1][n];if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)return;const e=t.stat(a.filePath);if(!e)continue;o=e.type}const c=_(e,t[0][n],o),l=u("fs").internalModuleStat(s);r.readdirResults.push(c),(c.isDirectory()||1===l)&&r.pathsQueue.push(i.join(c.path,c.name))}}(t):function handleFilePaths({result:t,currentPath:e,context:r}){for(let s=0;s<t.length;s++){const n=i.join(e,t[s]),a=i.relative(r.basePath,n),o=u("fs").internalModuleStat(n);r.readdirResults.push(a),1===o&&r.pathsQueue.push(n)}}(t);const{readdir:E}=t;t.readdir=function(e,r,s){if(F(s="function"==typeof r?r:s,"callback"),r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return void function readdirRecursive(t,e,r){const s={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};let n=0;!function read(t){const e=new h.FSReqCallback;e.oncomplete=(e,i)=>{e?r(e):void 0!==i?(processReaddirResult({result:i,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)):r(null,s.readdirResults)};const a=splitPath(t);if(a.isAsar){let e;const{asarPath:o,filePath:c}=a,l=getOrCreateArchive(o);if(!l){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(r,[t])}if(e=l.readdir(c),!e){const t=createError("NOT_FOUND",{asarPath:o,filePath:c});return void nextTick(r,[t])}s.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))]),processReaddirResult({result:e,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)}else h.readdir(t,s.encoding,s.withFileTypes,e)}(s.pathsQueue[n++])}(e,r,s);const n=splitPath(e);if(!n.isAsar)return E.apply(this,arguments);const{asarPath:a,filePath:o}=n,c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.readdir(o);if(l)if(r?.withFileTypes){const e=[];for(const r of l){const n=i.join(o,r),l=c.stat(n);if(!l){const t=createError("NOT_FOUND",{asarPath:a,filePath:n});return void nextTick(s,[t])}e.push(new t.Dirent(r,l.type))}nextTick(s,[null,e])}else nextTick(s,[null,l]);else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}};const{readdir:k}=t.promises;t.promises.readdir=async function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return async function readdirRecursivePromises(t,e){const r=[],s=splitPath(t);let n=[];const a=Boolean(e?.withFileTypes);let o=[];if(s.isAsar){const e=getOrCreateArchive(s.asarPath);if(!e)return r;const n=e.readdir(s.filePath);if(!n)return r;o=n,a&&(o=[[...o],o.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else o=await h.readdir(i.toNamespacedPath(t),e.encoding,a,b);if(n=[[t,o]],a)for(;n.length>0;){const{0:t,1:s}=n.pop();for(const a of getDirents(t,s))if(r.push(a),a.isDirectory()){const r=i.join(t,a.name),s=splitPath(r);let o;if(s.isAsar){const t=getOrCreateArchive(s.asarPath);if(!t)continue;const e=t.readdir(s.filePath);if(!e)continue;o=[[...e],e.map((t=>u("fs").internalModuleStat(i.join(r,t))))]}else o=await h.readdir(r,e.encoding,!0,b);n.push([r,o])}}else for(;n.length>0;){const{0:s,1:a}=n.pop();for(const o of a){const a=i.join(s,o),c=u("fs").internalModuleStat(a);if(r.push(i.relative(t,a)),1===c){const t=splitPath(a);let s=[];if(t.isAsar){const e=getOrCreateArchive(t.asarPath);if(!e)return;const n=e.readdir(t.filePath);if(!n)return r;s=n}else s=await h.readdir(i.toNamespacedPath(a),e.encoding,!1,b);n.push([a,s])}}}return r}(e,r);const s=splitPath(e);if(!s.isAsar)return k(e,r);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:n}));const c=o.readdir(a);if(!c)return l.reject(createError("NOT_FOUND",{asarPath:n,filePath:a}));if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return l.resolve(e)}return l.resolve(c)};const{readdirSync:V}=t;t.readdirSync=function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return function readdirSyncRecursive(t,e){const r={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};function read(t){let e;const s=splitPath(t);if(s.isAsar){const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return;if(e=o.readdir(a),!e)return;r.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else e=h.readdir(i.toNamespacedPath(t),r.encoding,r.withFileTypes);void 0!==e&&processReaddirResult({result:e,currentPath:t,context:r})}for(let t=0;t<r.pathsQueue.length;t++)read(r.pathsQueue[t]);return r.readdirResults}(e,r);const s=splitPath(e);if(!s.isAsar)return V.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.readdir(a);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return e}return c};u("modules").overrideReadFileSync((t=>{const e=splitPath(t);if(e.isAsar)try{return readFileFromArchiveSync(e,void 0)}catch{return!1}}));const{internalModuleStat:x}=h;u("fs").internalModuleStat=t=>{const e=splitPath(t);if(!e.isAsar)return x(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n)return-34;const i=n.stat(s);return i?i.type===w.kDirectory?1:0:-34};const{kUsePromises:b}=h;if("win32"===process.platform){const{mkdir:e}=t;t.mkdir=(t,r,s)=>{"function"==typeof r&&(s=r,r={});const n=splitPath(t);if(n.isAsar&&n.filePath.length>0){const t=createError("NOT_DIR");nextTick(s,[t])}else e(t,r,s)},t.promises.mkdir=a.promisify(t.mkdir);const{mkdirSync:r}=t;t.mkdirSync=function(t,e){const s=splitPath(t);if(s.isAsar&&s.filePath.length)throw createError("NOT_DIR");return r(t,e)}}function invokeWithNoAsar(t){return function(){const e=process.noAsar;process.noAsar=!0;try{return t.apply(this,arguments)}finally{process.noAsar=e}}}overrideAPI(t,"copyFile"),overrideAPISync(t,"copyFileSync"),overrideAPI(t,"open"),overrideAPISync(process,"dlopen",1),overrideAPISync(c._extensions,".node",1),overrideAPISync(t,"openSync");const overrideChildProcess=t=>{const{exec:e,execSync:r}=t;t.exec=invokeWithNoAsar(e),t.exec[a.promisify.custom]=A("exec",invokeWithNoAsar(e[a.promisify.custom])),t.execSync=invokeWithNoAsar(r),overrideAPI(t,"execFile"),overrideAPISync(t,"execFileSync")},C=new WeakSet;if(process.env.ELECTRON_EAGER_ASAR_HOOK_FOR_TESTING)overrideChildProcess(r("child_process"));else{const t=c._load;c._load=(e,...r)=>{const s=t(e,...r);if(("child_process"===e||"node:child_process"===e)&&!C.has(s)){C.add(s);overrideChildProcess(s)}return s}}}},buffer:t=>{t.exports=require("buffer")},child_process:t=>{t.exports=require("child_process")},crypto:t=>{t.exports=require("crypto")},fs:t=>{t.exports=require("fs")},module:t=>{t.exports=require("module")},os:t=>{t.exports=require("os")},path:t=>{t.exports=require("path")},util:t=>{t.exports=require("util")}},e={};function __webpack_require__(r){var s=e[r];if(void 0!==s)return s.exports;var n=e[r]={exports:{}};return t[r](n,n.exports,__webpack_require__),n.exports}var r={};(()=>{var t=r;Object.defineProperty(t,"__esModule",{value:!0});if((0,__webpack_require__("./lib/node/asar-fs-wrapper.ts").wrapFsWithAsar)(__webpack_require__("fs")),globalThis.blinkfetch){const t=["fetch","Response","FormData","Request","Headers","EventSource"];for(const e of t)globalThis[e]=globalThis[`blink${e}`]}const e=__webpack_require__("child_process"),s=e.fork;e.fork=(t,e,r)=>(null==e?e=[]:"object"!=typeof e||Array.isArray(e)||(r=e,e=[]),"string"!=typeof t||!Array.isArray(e)||"object"!=typeof r&&void 0!==r||((r=r??{}).env=Object.create(r.env||process.env),r.env.ELECTRON_RUN_AS_NODE="1",r.execPath||"darwin"!==process.platform||(r.execPath=process.helperExecPath)),s(t,e,r));const n=__webpack_require__("path"),i=__webpack_require__("module"),a=process.resourcesPath+n.sep,o=i._nodeModulePaths;i._nodeModulePaths=function(t){const e=o(t);return(n.resolve(t)+n.sep).startsWith(a)?e.filter((function(t){return t.startsWith(a)})):e}})()})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

Error: The specified module could not be found.
C:\Users\ygaba\source\repos\BPSR-Meter\node_modules\electron\dist\resources\build\Release\windivert.node
    at process.func [as dlopen] (node:electron/js2c/node_init:2:2617)
    at file:///C:/Users/ygaba/source/repos/BPSR-Meter/out/main/server.js:735:9
    at ModuleJob.run (node:internal/modules/esm/module_job:345:25)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:665:26)
    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:132:5) {
  code: 'ERR_DLOPEN_FAILED'
}

Node.js v22.20.0
[2025-10-25T01:40:56.080Z] SERVER PROCESS EXITED with code: 1, signal: null
[2025-10-25T01:40:56.081Z] SERVER PROCESS CLOSED with code: 1
[2025-10-25T01:41:05.767Z] ERROR: Server did not respond in time (10s timeout)
[2025-10-25T01:41:08.377Z] All windows closed
[2025-10-25T01:41:08.378Z] Closing application (not macOS)
[2025-10-25T01:41:08.378Z] App closing, cleaning up processes...
[2025-10-25T01:42:45.746Z] ==== ELECTRON START ====
[2025-10-25T01:42:45.811Z] Electron app ready, starting createWindow()
[2025-10-25T01:42:45.812Z] === STARTING CREATEWINDOW ===
[2025-10-25T01:42:45.813Z] Node.js process: v22.20.0
[2025-10-25T01:42:45.813Z] Electron version: 38.3.0
[2025-10-25T01:42:45.814Z] Current directory: C:\Users\ygaba\source\repos\BPSR-Meter\out\main
[2025-10-25T01:42:45.814Z] Attempting to kill processes on port 8989...
[2025-10-25T01:42:45.870Z] Searching for available port starting from: 8989
[2025-10-25T01:42:45.871Z] Checking port availability: 8989
[2025-10-25T01:42:45.874Z] Port 8989 is available
[2025-10-25T01:42:45.875Z] Available port found: 8989
[2025-10-25T01:42:45.941Z] User data path: C:\Users\ygaba\AppData\Roaming\bpsr-meter
[2025-10-25T01:42:45.941Z] Launching server.js on port 8989 with path: C:\Users\ygaba\source\repos\BPSR-Meter\out\main\server.js
[2025-10-25T01:42:46.322Z] SERVER STDERR: node:electron/js2c/node_init:2
(()=>{"use strict";var t={"./lib/node/asar-fs-wrapper.ts":(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.wrapFsWithAsar=void 0;const s=r("buffer"),n=r("fs"),i=r("path"),a=r("util"),o=process._linkedBinding("electron_common_asar"),c=r("module"),l=global.Promise,f=process.env.ELECTRON_NO_ASAR&&"browser"!==process.type&&"renderer"!==process.type,u=process.internalBinding;delete process.internalBinding;const nextTick=(t,e=[])=>{process.nextTick((()=>t(...e)))},h=u("fs"),p=new Map,getOrCreateArchive=t=>{if(p.has(t))return p.get(t);try{const e=new o.Archive(t);return p.set(t,e),e}catch{return null}};process._getOrCreateArchive=getOrCreateArchive;const d=/\.asar/i,{getValidatedPath:y,getOptions:P,getDirent:_}=require("internal/fs/utils"),{assignFunctionName:A}=require("internal/util"),{validateBoolean:N,validateFunction:F}=require("internal/validators"),{URL:I}=require("internal/url"),splitPath=t=>{if(process.noAsar||f)return{isAsar:!1};let e=t;return s.Buffer.isBuffer(t)&&(e=t.toString()),e instanceof I&&(e=y(e)),"string"!=typeof e?{isAsar:!1}:d.test(e)?o.splitPath(i.normalize(e)):{isAsar:!1}};let v=0;const O=process.getuid?.()??0,g=process.getgid?.()??0,m=new Date;function getDirents(t,{0:e,1:r}){for(let s=0;s<e.length;s++){let n=r[s];const a=splitPath(i.join(t,e[s]));if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)continue;const e=t.stat(a.filePath);if(!e)continue;n=e.type}e[s]=_(t,e[s],n)}return e}var w;!function(t){t[t.kFile=n.constants.UV_DIRENT_FILE]="kFile",t[t.kDirectory=n.constants.UV_DIRENT_DIR]="kDirectory",t[t.kLink=n.constants.UV_DIRENT_LINK]="kLink"}(w||(w={}));const S=new Map([[w.kFile,n.constants.S_IFREG],[w.kDirectory,n.constants.S_IFDIR],[w.kLink,n.constants.S_IFLNK]]),asarStatsToFsStats=function(t){const{Stats:e}=r("fs");return new e(1,n.constants.S_IROTH|n.constants.S_IRGRP|n.constants.S_IRUSR|n.constants.S_IWUSR|S.get(t.type),1,O,g,0,void 0,++v,t.size,void 0,m.getTime(),m.getTime(),m.getTime(),m.getTime())},createError=(t,{asarPath:e,filePath:r}={})=>{let s;switch(t){case"NOT_FOUND":s=new Error(`ENOENT, ${r} not found in ${e}`),s.code="ENOENT",s.errno=-2;break;case"NOT_DIR":s=new Error("ENOTDIR, not a directory"),s.code="ENOTDIR",s.errno=-20;break;case"NO_ACCESS":s=new Error(`EACCES: permission denied, access '${r}'`),s.code="EACCES",s.errno=-13;break;case"INVALID_ARCHIVE":s=new Error(`Invalid package ${e}`);break;default:throw new Error(`Invalid error type "${t}" passed to createError.`)}return s},overrideAPISync=function(t,e,r,s=!1){null==r&&(r=0);const n=t[e],func=function(...t){const e=t[r],s=splitPath(e);if(!s.isAsar)return n.apply(this,t);const{asarPath:i,filePath:a}=s,o=getOrCreateArchive(i);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:i});const c=o.copyFileOut(a);if(!c)throw createError("NOT_FOUND",{asarPath:i,filePath:a});return t[r]=c,n.apply(this,t)};if(s)return func;t[e]=func},overrideAPI=function(t,e,r){null==r&&(r=0);const s=t[e];t[e]=function(...n){const i=n[r],a=splitPath(i);if(!a.isAsar)return s.apply(this,n);const{asarPath:o,filePath:c}=a,l=n[n.length-1];if("function"!=typeof l)return overrideAPISync(t,e,r,!0).apply(this,n);const f=getOrCreateArchive(o);if(!f){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(l,[t])}const u=f.copyFileOut(c);if(u)return n[r]=u,s.apply(this,n);{const t=createError("NOT_FOUND",{asarPath:o,filePath:c});nextTick(l,[t])}},s[a.promisify.custom]&&(t[e][a.promisify.custom]=A(e,makePromiseFunction(s[a.promisify.custom],r))),t.promises&&t.promises[e]&&(t.promises[e]=makePromiseFunction(t.promises[e],r))};let D;function validateBufferIntegrity(t,e){if(!e)return;D=D||r("crypto");const s=D.createHash(e.algorithm).update(t).digest("hex");s!==e.hash&&(console.error(`ASAR Integrity Violation: got a hash mismatch (${s} vs ${e.hash})`),process.exit(1))}const makePromiseFunction=function(t,e){return function(...r){const s=r[e],n=splitPath(s);if(!n.isAsar)return t.apply(this,r);const{asarPath:i,filePath:a}=n,o=getOrCreateArchive(i);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:i}));const c=o.copyFileOut(a);return c?(r[e]=c,t.apply(this,r)):l.reject(createError("NOT_FOUND",{asarPath:i,filePath:a}))}};e.wrapFsWithAsar=t=>{const e=new Map,logASARAccess=(s,n,a)=>{if(process.env.ELECTRON_LOG_ASAR_READS){if(!e.has(s)){const n=`${i.basename(s,".asar")}-access-log.txt`,a=i.join(r("os").tmpdir(),n);e.set(s,t.openSync(a,"a"))}t.writeSync(e.get(s),`${a}: ${n}\n`)}},shouldThrowStatError=t=>!t||"object"!=typeof t||!1!==t.throwIfNoEntry,{lstatSync:n}=t;t.lstatSync=(t,e)=>{const r=splitPath(t);if(!r.isAsar)return n(t,e);const{asarPath:s,filePath:i}=r,a=getOrCreateArchive(s);if(!a){if(shouldThrowStatError(e))throw createError("INVALID_ARCHIVE",{asarPath:s});return null}const o=a.stat(i);if(!o){if(shouldThrowStatError(e))throw createError("NOT_FOUND",{asarPath:s,filePath:i});return null}return asarStatsToFsStats(o)};const{lstat:o}=t;t.lstat=(t,e,r)=>{const s=splitPath(t);if("function"==typeof e&&(r=e,e={}),!s.isAsar)return o(t,e,r);const{asarPath:n,filePath:i}=s,a=getOrCreateArchive(n);if(!a){const t=createError("INVALID_ARCHIVE",{asarPath:n});return void nextTick(r,[t])}const c=a.stat(i);if(!c){const t=createError("NOT_FOUND",{asarPath:n,filePath:i});return void nextTick(r,[t])}const l=asarStatsToFsStats(c);nextTick(r,[null,l])},t.promises.lstat=a.promisify(t.lstat);const{statSync:f}=t;t.statSync=(e,r)=>{const{isAsar:s}=splitPath(e);return s?t.lstatSync(e,r):f(e,r)};const{stat:p}=t;t.stat=(e,r,s)=>{const{isAsar:n}=splitPath(e);if("function"==typeof r&&(s=r,r={}),!n)return p(e,r,s);process.nextTick((()=>t.lstat(e,r,s)))},t.promises.stat=a.promisify(t.stat);const wrapRealpathSync=function(t){return function(e,r){const s=splitPath(e);if(!s.isAsar)return t.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.realpath(a);if(!1===c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});return i.join(t(n,r),c)}},{realpathSync:d}=t;t.realpathSync=wrapRealpathSync(d),t.realpathSync.native=wrapRealpathSync(d.native);const wrapRealpath=function(t){return function(e,r,s){const n=splitPath(e);if(!n.isAsar)return t.apply(this,arguments);const{asarPath:a,filePath:o}=n;arguments.length<3&&(s=r,r={});const c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.realpath(o);if(!1!==l)t(a,r,((t,e)=>{if(null===t){const t=i.join(e,l);s(null,t)}else s(t)}));else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}}},{realpath:I}=t;t.realpath=wrapRealpath(I),t.realpath.native=wrapRealpath(I.native),t.promises.realpath=a.promisify(t.realpath.native);const{exists:v}=t;t.exists=function exists(t,e){let r;try{r=splitPath(t)}catch{return void nextTick(e,[!1])}if(!r.isAsar)return v(t,e);const{asarPath:s,filePath:n}=r,i=getOrCreateArchive(s);if(!i){const t=createError("INVALID_ARCHIVE",{asarPath:s});return void nextTick(e,[t])}const a=!1!==i.stat(n);nextTick(e,[a])},t.exists[a.promisify.custom]=function exists(t){const e=splitPath(t);if(!e.isAsar)return v[a.promisify.custom](t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n){const t=createError("INVALID_ARCHIVE",{asarPath:r});return l.reject(t)}return l.resolve(!1!==n.stat(s))};const{existsSync:O}=t;t.existsSync=t=>{let e;try{e=splitPath(t)}catch{return!1}if(!e.isAsar)return O(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);return!!n&&!1!==n.stat(s)};const{access:g}=t;t.access=function(e,r,s){const n=splitPath(e);if(!n.isAsar)return g.apply(this,arguments);const{asarPath:i,filePath:a}=n;"function"==typeof r&&(s=r,r=t.constants.F_OK);const o=getOrCreateArchive(i);if(!o){const t=createError("INVALID_ARCHIVE",{asarPath:i});return void nextTick(s,[t])}const c=o.getFileInfo(a);if(!c){const t=createError("NOT_FOUND",{asarPath:i,filePath:a});return void nextTick(s,[t])}if(c.unpacked){const e=o.copyFileOut(a);return t.access(e,r,s)}if(o.stat(a))if(r&t.constants.W_OK){const t=createError("NO_ACCESS",{asarPath:i,filePath:a});nextTick(s,[t])}else nextTick(s);else{const t=createError("NOT_FOUND",{asarPath:i,filePath:a});nextTick(s,[t])}};const{access:m}=t.promises;t.promises.access=function(e,r){if(!splitPath(e).isAsar)return m.apply(this,arguments);return a.promisify(t.access)(e,r)};const{accessSync:S}=t;function fsReadFileAsar(e,r,n){const i=splitPath(e);if(i.isAsar){const{asarPath:e,filePath:a}=i;if("function"==typeof r)n=r,r={encoding:null};else if("string"==typeof r)r={encoding:r};else if(null==r)r={encoding:null};else if("object"!=typeof r)throw new TypeError("Bad arguments");const{encoding:o}=r,c=getOrCreateArchive(e);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:e});return void nextTick(n,[t])}const l=c.getFileInfo(a);if(!l){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}if(0===l.size)return void nextTick(n,[null,o?"":s.Buffer.alloc(0)]);if(l.unpacked){const e=c.copyFileOut(a);return t.readFile(e,r,n)}const f=s.Buffer.alloc(l.size),u=c.getFdAndValidateIntegrityLater();if(!(u>=0)){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}logASARAccess(e,a,l.offset),t.read(u,f,0,l.size,l.offset,(t=>{validateBufferIntegrity(f,l.integrity),n(t,o?f.toString(o):f)}))}}t.accessSync=function(e,r){const s=splitPath(e);if(!s.isAsar)return S.apply(this,arguments);const{asarPath:n,filePath:i}=s;null==r&&(r=t.constants.F_OK);const a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(o.unpacked){const e=a.copyFileOut(i);return t.accessSync(e,r)}if(!a.stat(i))throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(r&t.constants.W_OK)throw createError("NO_ACCESS",{asarPath:n,filePath:i})};const{readFile:D}=t;t.readFile=function(t,e,r){return splitPath(t).isAsar?fsReadFileAsar(t,e,r):D.apply(this,arguments)};const{readFile:R}=t.promises;function readFileFromArchiveSync(e,r){const{asarPath:n,filePath:i}=e,a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(0===o.size)return r?"":s.Buffer.alloc(0);if(o.unpacked){const e=a.copyFileOut(i);return t.readFileSync(e,r)}if(r){if("string"==typeof r)r={encoding:r};else if("object"!=typeof r)throw new TypeError("Bad arguments")}else r={encoding:null};const{encoding:c}=r,l=s.Buffer.alloc(o.size),f=a.getFdAndValidateIntegrityLater();if(!(f>=0))throw createError("NOT_FOUND",{asarPath:n,filePath:i});return logASARAccess(n,i,o.offset),t.readSync(f,l,0,o.size,o.offset),validateBufferIntegrity(l,o.integrity),c?l.toString(c):l}t.promises.readFile=function(t,e){if(!splitPath(t).isAsar)return R.apply(this,arguments);return a.promisify(fsReadFileAsar)(t,e)};const{readFileSync:T}=t;t.readFileSync=function(t,e){const r=splitPath(t);return r.isAsar?readFileFromArchiveSync(r,e):T.apply(this,arguments)};const processReaddirResult=t=>t.context.withFileTypes?function handleDirents({result:t,currentPath:e,context:r}){const s=t[0].length;for(let n=0;n<s;n++){const s=i.join(e,t[0][n]),a=splitPath(s);let o=t[1][n];if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)return;const e=t.stat(a.filePath);if(!e)continue;o=e.type}const c=_(e,t[0][n],o),l=u("fs").internalModuleStat(s);r.readdirResults.push(c),(c.isDirectory()||1===l)&&r.pathsQueue.push(i.join(c.path,c.name))}}(t):function handleFilePaths({result:t,currentPath:e,context:r}){for(let s=0;s<t.length;s++){const n=i.join(e,t[s]),a=i.relative(r.basePath,n),o=u("fs").internalModuleStat(n);r.readdirResults.push(a),1===o&&r.pathsQueue.push(n)}}(t);const{readdir:E}=t;t.readdir=function(e,r,s){if(F(s="function"==typeof r?r:s,"callback"),r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return void function readdirRecursive(t,e,r){const s={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};let n=0;!function read(t){const e=new h.FSReqCallback;e.oncomplete=(e,i)=>{e?r(e):void 0!==i?(processReaddirResult({result:i,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)):r(null,s.readdirResults)};const a=splitPath(t);if(a.isAsar){let e;const{asarPath:o,filePath:c}=a,l=getOrCreateArchive(o);if(!l){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(r,[t])}if(e=l.readdir(c),!e){const t=createError("NOT_FOUND",{asarPath:o,filePath:c});return void nextTick(r,[t])}s.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))]),processReaddirResult({result:e,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)}else h.readdir(t,s.encoding,s.withFileTypes,e)}(s.pathsQueue[n++])}(e,r,s);const n=splitPath(e);if(!n.isAsar)return E.apply(this,arguments);const{asarPath:a,filePath:o}=n,c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.readdir(o);if(l)if(r?.withFileTypes){const e=[];for(const r of l){const n=i.join(o,r),l=c.stat(n);if(!l){const t=createError("NOT_FOUND",{asarPath:a,filePath:n});return void nextTick(s,[t])}e.push(new t.Dirent(r,l.type))}nextTick(s,[null,e])}else nextTick(s,[null,l]);else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}};const{readdir:k}=t.promises;t.promises.readdir=async function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return async function readdirRecursivePromises(t,e){const r=[],s=splitPath(t);let n=[];const a=Boolean(e?.withFileTypes);let o=[];if(s.isAsar){const e=getOrCreateArchive(s.asarPath);if(!e)return r;const n=e.readdir(s.filePath);if(!n)return r;o=n,a&&(o=[[...o],o.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else o=await h.readdir(i.toNamespacedPath(t),e.encoding,a,b);if(n=[[t,o]],a)for(;n.length>0;){const{0:t,1:s}=n.pop();for(const a of getDirents(t,s))if(r.push(a),a.isDirectory()){const r=i.join(t,a.name),s=splitPath(r);let o;if(s.isAsar){const t=getOrCreateArchive(s.asarPath);if(!t)continue;const e=t.readdir(s.filePath);if(!e)continue;o=[[...e],e.map((t=>u("fs").internalModuleStat(i.join(r,t))))]}else o=await h.readdir(r,e.encoding,!0,b);n.push([r,o])}}else for(;n.length>0;){const{0:s,1:a}=n.pop();for(const o of a){const a=i.join(s,o),c=u("fs").internalModuleStat(a);if(r.push(i.relative(t,a)),1===c){const t=splitPath(a);let s=[];if(t.isAsar){const e=getOrCreateArchive(t.asarPath);if(!e)return;const n=e.readdir(t.filePath);if(!n)return r;s=n}else s=await h.readdir(i.toNamespacedPath(a),e.encoding,!1,b);n.push([a,s])}}}return r}(e,r);const s=splitPath(e);if(!s.isAsar)return k(e,r);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:n}));const c=o.readdir(a);if(!c)return l.reject(createError("NOT_FOUND",{asarPath:n,filePath:a}));if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return l.resolve(e)}return l.resolve(c)};const{readdirSync:V}=t;t.readdirSync=function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return function readdirSyncRecursive(t,e){const r={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};function read(t){let e;const s=splitPath(t);if(s.isAsar){const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return;if(e=o.readdir(a),!e)return;r.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else e=h.readdir(i.toNamespacedPath(t),r.encoding,r.withFileTypes);void 0!==e&&processReaddirResult({result:e,currentPath:t,context:r})}for(let t=0;t<r.pathsQueue.length;t++)read(r.pathsQueue[t]);return r.readdirResults}(e,r);const s=splitPath(e);if(!s.isAsar)return V.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.readdir(a);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return e}return c};u("modules").overrideReadFileSync((t=>{const e=splitPath(t);if(e.isAsar)try{return readFileFromArchiveSync(e,void 0)}catch{return!1}}));const{internalModuleStat:x}=h;u("fs").internalModuleStat=t=>{const e=splitPath(t);if(!e.isAsar)return x(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n)return-34;const i=n.stat(s);return i?i.type===w.kDirectory?1:0:-34};const{kUsePromises:b}=h;if("win32"===process.platform){const{mkdir:e}=t;t.mkdir=(t,r,s)=>{"function"==typeof r&&(s=r,r={});const n=splitPath(t);if(n.isAsar&&n.filePath.length>0){const t=createError("NOT_DIR");nextTick(s,[t])}else e(t,r,s)},t.promises.mkdir=a.promisify(t.mkdir);const{mkdirSync:r}=t;t.mkdirSync=function(t,e){const s=splitPath(t);if(s.isAsar&&s.filePath.length)throw createError("NOT_DIR");return r(t,e)}}function invokeWithNoAsar(t){return function(){const e=process.noAsar;process.noAsar=!0;try{return t.apply(this,arguments)}finally{process.noAsar=e}}}overrideAPI(t,"copyFile"),overrideAPISync(t,"copyFileSync"),overrideAPI(t,"open"),overrideAPISync(process,"dlopen",1),overrideAPISync(c._extensions,".node",1),overrideAPISync(t,"openSync");const overrideChildProcess=t=>{const{exec:e,execSync:r}=t;t.exec=invokeWithNoAsar(e),t.exec[a.promisify.custom]=A("exec",invokeWithNoAsar(e[a.promisify.custom])),t.execSync=invokeWithNoAsar(r),overrideAPI(t,"execFile"),overrideAPISync(t,"execFileSync")},C=new WeakSet;if(process.env.ELECTRON_EAGER_ASAR_HOOK_FOR_TESTING)overrideChildProcess(r("child_process"));else{const t=c._load;c._load=(e,...r)=>{const s=t(e,...r);if(("child_process"===e||"node:child_process"===e)&&!C.has(s)){C.add(s);overrideChildProcess(s)}return s}}}},buffer:t=>{t.exports=require("buffer")},child_process:t=>{t.exports=require("child_process")},crypto:t=>{t.exports=require("crypto")},fs:t=>{t.exports=require("fs")},module:t=>{t.exports=require("module")},os:t=>{t.exports=require("os")},path:t=>{t.exports=require("path")},util:t=>{t.exports=require("util")}},e={};function __webpack_require__(r){var s=e[r];if(void 0!==s)return s.exports;var n=e[r]={exports:{}};return t[r](n,n.exports,__webpack_require__),n.exports}var r={};(()=>{var t=r;Object.defineProperty(t,"__esModule",{value:!0});if((0,__webpack_require__("./lib/node/asar-fs-wrapper.ts").wrapFsWithAsar)(__webpack_require__("fs")),globalThis.blinkfetch){const t=["fetch","Response","FormData","Request","Headers","EventSource"];for(const e of t)globalThis[e]=globalThis[`blink${e}`]}const e=__webpack_require__("child_process"),s=e.fork;e.fork=(t,e,r)=>(null==e?e=[]:"object"!=typeof e||Array.isArray(e)||(r=e,e=[]),"string"!=typeof t||!Array.isArray(e)||"object"!=typeof r&&void 0!==r||((r=r??{}).env=Object.create(r.env||process.env),r.env.ELECTRON_RUN_AS_NODE="1",r.execPath||"darwin"!==process.platform||(r.execPath=process.helperExecPath)),s(t,e,r));const n=__webpack_require__("path"),i=__webpack_require__("module"),a=process.resourcesPath+n.sep,o=i._nodeModulePaths;i._nodeModulePaths=function(t){const e=o(t);return(n.resolve(t)+n.sep).startsWith(a)?e.filter((function(t){return t.startsWith(a)})):e}})()})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

Error: The specified module could not be found.
C:\Users\ygaba\source\repos\BPSR-Meter\node_modules\electron\dist\resources\build\Release\windivert.node
    at process.func [as dlopen] (node:electron/js2c/node_init:2:2617)
    at file:///C:/Users/ygaba/source/repos/BPSR-Meter/out/main/server.js:735:9
    at ModuleJob.run (node:internal/modules/esm/module_job:345:25)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:665:26)
    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:132:5) {
  code: 'ERR_DLOPEN_FAILED'
}

Node.js v22.20.0
[2025-10-25T01:42:46.333Z] SERVER PROCESS EXITED with code: 1, signal: null
[2025-10-25T01:42:46.334Z] SERVER PROCESS CLOSED with code: 1
[2025-10-25T01:42:55.966Z] ERROR: Server did not respond in time (10s timeout)
[2025-10-25T01:42:58.623Z] All windows closed
[2025-10-25T01:42:58.624Z] Closing application (not macOS)
[2025-10-25T01:42:58.624Z] App closing, cleaning up processes...
[2025-10-25T01:47:08.328Z] ==== ELECTRON START ====
[2025-10-25T01:47:08.395Z] Electron app ready, starting createWindow()
[2025-10-25T01:47:08.396Z] === STARTING CREATEWINDOW ===
[2025-10-25T01:47:08.396Z] Node.js process: v22.20.0
[2025-10-25T01:47:08.397Z] Electron version: 38.3.0
[2025-10-25T01:47:08.398Z] Current directory: C:\Users\ygaba\source\repos\BPSR-Meter\out\main
[2025-10-25T01:47:08.398Z] Attempting to kill processes on port 8989...
[2025-10-25T01:47:08.453Z] Searching for available port starting from: 8989
[2025-10-25T01:47:08.453Z] Checking port availability: 8989
[2025-10-25T01:47:08.456Z] Port 8989 is available
[2025-10-25T01:47:08.456Z] Available port found: 8989
[2025-10-25T01:47:08.531Z] User data path: C:\Users\ygaba\AppData\Roaming\bpsr-meter
[2025-10-25T01:47:08.532Z] Launching server.js on port 8989 with path: C:\Users\ygaba\source\repos\BPSR-Meter\out\main\server.js
[2025-10-25T01:47:08.879Z] SERVER STDERR: node:electron/js2c/node_init:2
(()=>{"use strict";var t={"./lib/node/asar-fs-wrapper.ts":(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.wrapFsWithAsar=void 0;const s=r("buffer"),n=r("fs"),i=r("path"),a=r("util"),o=process._linkedBinding("electron_common_asar"),c=r("module"),l=global.Promise,f=process.env.ELECTRON_NO_ASAR&&"browser"!==process.type&&"renderer"!==process.type,u=process.internalBinding;delete process.internalBinding;const nextTick=(t,e=[])=>{process.nextTick((()=>t(...e)))},h=u("fs"),p=new Map,getOrCreateArchive=t=>{if(p.has(t))return p.get(t);try{const e=new o.Archive(t);return p.set(t,e),e}catch{return null}};process._getOrCreateArchive=getOrCreateArchive;const d=/\.asar/i,{getValidatedPath:y,getOptions:P,getDirent:_}=require("internal/fs/utils"),{assignFunctionName:A}=require("internal/util"),{validateBoolean:N,validateFunction:F}=require("internal/validators"),{URL:I}=require("internal/url"),splitPath=t=>{if(process.noAsar||f)return{isAsar:!1};let e=t;return s.Buffer.isBuffer(t)&&(e=t.toString()),e instanceof I&&(e=y(e)),"string"!=typeof e?{isAsar:!1}:d.test(e)?o.splitPath(i.normalize(e)):{isAsar:!1}};let v=0;const O=process.getuid?.()??0,g=process.getgid?.()??0,m=new Date;function getDirents(t,{0:e,1:r}){for(let s=0;s<e.length;s++){let n=r[s];const a=splitPath(i.join(t,e[s]));if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)continue;const e=t.stat(a.filePath);if(!e)continue;n=e.type}e[s]=_(t,e[s],n)}return e}var w;!function(t){t[t.kFile=n.constants.UV_DIRENT_FILE]="kFile",t[t.kDirectory=n.constants.UV_DIRENT_DIR]="kDirectory",t[t.kLink=n.constants.UV_DIRENT_LINK]="kLink"}(w||(w={}));const S=new Map([[w.kFile,n.constants.S_IFREG],[w.kDirectory,n.constants.S_IFDIR],[w.kLink,n.constants.S_IFLNK]]),asarStatsToFsStats=function(t){const{Stats:e}=r("fs");return new e(1,n.constants.S_IROTH|n.constants.S_IRGRP|n.constants.S_IRUSR|n.constants.S_IWUSR|S.get(t.type),1,O,g,0,void 0,++v,t.size,void 0,m.getTime(),m.getTime(),m.getTime(),m.getTime())},createError=(t,{asarPath:e,filePath:r}={})=>{let s;switch(t){case"NOT_FOUND":s=new Error(`ENOENT, ${r} not found in ${e}`),s.code="ENOENT",s.errno=-2;break;case"NOT_DIR":s=new Error("ENOTDIR, not a directory"),s.code="ENOTDIR",s.errno=-20;break;case"NO_ACCESS":s=new Error(`EACCES: permission denied, access '${r}'`),s.code="EACCES",s.errno=-13;break;case"INVALID_ARCHIVE":s=new Error(`Invalid package ${e}`);break;default:throw new Error(`Invalid error type "${t}" passed to createError.`)}return s},overrideAPISync=function(t,e,r,s=!1){null==r&&(r=0);const n=t[e],func=function(...t){const e=t[r],s=splitPath(e);if(!s.isAsar)return n.apply(this,t);const{asarPath:i,filePath:a}=s,o=getOrCreateArchive(i);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:i});const c=o.copyFileOut(a);if(!c)throw createError("NOT_FOUND",{asarPath:i,filePath:a});return t[r]=c,n.apply(this,t)};if(s)return func;t[e]=func},overrideAPI=function(t,e,r){null==r&&(r=0);const s=t[e];t[e]=function(...n){const i=n[r],a=splitPath(i);if(!a.isAsar)return s.apply(this,n);const{asarPath:o,filePath:c}=a,l=n[n.length-1];if("function"!=typeof l)return overrideAPISync(t,e,r,!0).apply(this,n);const f=getOrCreateArchive(o);if(!f){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(l,[t])}const u=f.copyFileOut(c);if(u)return n[r]=u,s.apply(this,n);{const t=createError("NOT_FOUND",{asarPath:o,filePath:c});nextTick(l,[t])}},s[a.promisify.custom]&&(t[e][a.promisify.custom]=A(e,makePromiseFunction(s[a.promisify.custom],r))),t.promises&&t.promises[e]&&(t.promises[e]=makePromiseFunction(t.promises[e],r))};let D;function validateBufferIntegrity(t,e){if(!e)return;D=D||r("crypto");const s=D.createHash(e.algorithm).update(t).digest("hex");s!==e.hash&&(console.error(`ASAR Integrity Violation: got a hash mismatch (${s} vs ${e.hash})`),process.exit(1))}const makePromiseFunction=function(t,e){return function(...r){const s=r[e],n=splitPath(s);if(!n.isAsar)return t.apply(this,r);const{asarPath:i,filePath:a}=n,o=getOrCreateArchive(i);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:i}));const c=o.copyFileOut(a);return c?(r[e]=c,t.apply(this,r)):l.reject(createError("NOT_FOUND",{asarPath:i,filePath:a}))}};e.wrapFsWithAsar=t=>{const e=new Map,logASARAccess=(s,n,a)=>{if(process.env.ELECTRON_LOG_ASAR_READS){if(!e.has(s)){const n=`${i.basename(s,".asar")}-access-log.txt`,a=i.join(r("os").tmpdir(),n);e.set(s,t.openSync(a,"a"))}t.writeSync(e.get(s),`${a}: ${n}\n`)}},shouldThrowStatError=t=>!t||"object"!=typeof t||!1!==t.throwIfNoEntry,{lstatSync:n}=t;t.lstatSync=(t,e)=>{const r=splitPath(t);if(!r.isAsar)return n(t,e);const{asarPath:s,filePath:i}=r,a=getOrCreateArchive(s);if(!a){if(shouldThrowStatError(e))throw createError("INVALID_ARCHIVE",{asarPath:s});return null}const o=a.stat(i);if(!o){if(shouldThrowStatError(e))throw createError("NOT_FOUND",{asarPath:s,filePath:i});return null}return asarStatsToFsStats(o)};const{lstat:o}=t;t.lstat=(t,e,r)=>{const s=splitPath(t);if("function"==typeof e&&(r=e,e={}),!s.isAsar)return o(t,e,r);const{asarPath:n,filePath:i}=s,a=getOrCreateArchive(n);if(!a){const t=createError("INVALID_ARCHIVE",{asarPath:n});return void nextTick(r,[t])}const c=a.stat(i);if(!c){const t=createError("NOT_FOUND",{asarPath:n,filePath:i});return void nextTick(r,[t])}const l=asarStatsToFsStats(c);nextTick(r,[null,l])},t.promises.lstat=a.promisify(t.lstat);const{statSync:f}=t;t.statSync=(e,r)=>{const{isAsar:s}=splitPath(e);return s?t.lstatSync(e,r):f(e,r)};const{stat:p}=t;t.stat=(e,r,s)=>{const{isAsar:n}=splitPath(e);if("function"==typeof r&&(s=r,r={}),!n)return p(e,r,s);process.nextTick((()=>t.lstat(e,r,s)))},t.promises.stat=a.promisify(t.stat);const wrapRealpathSync=function(t){return function(e,r){const s=splitPath(e);if(!s.isAsar)return t.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.realpath(a);if(!1===c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});return i.join(t(n,r),c)}},{realpathSync:d}=t;t.realpathSync=wrapRealpathSync(d),t.realpathSync.native=wrapRealpathSync(d.native);const wrapRealpath=function(t){return function(e,r,s){const n=splitPath(e);if(!n.isAsar)return t.apply(this,arguments);const{asarPath:a,filePath:o}=n;arguments.length<3&&(s=r,r={});const c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.realpath(o);if(!1!==l)t(a,r,((t,e)=>{if(null===t){const t=i.join(e,l);s(null,t)}else s(t)}));else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}}},{realpath:I}=t;t.realpath=wrapRealpath(I),t.realpath.native=wrapRealpath(I.native),t.promises.realpath=a.promisify(t.realpath.native);const{exists:v}=t;t.exists=function exists(t,e){let r;try{r=splitPath(t)}catch{return void nextTick(e,[!1])}if(!r.isAsar)return v(t,e);const{asarPath:s,filePath:n}=r,i=getOrCreateArchive(s);if(!i){const t=createError("INVALID_ARCHIVE",{asarPath:s});return void nextTick(e,[t])}const a=!1!==i.stat(n);nextTick(e,[a])},t.exists[a.promisify.custom]=function exists(t){const e=splitPath(t);if(!e.isAsar)return v[a.promisify.custom](t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n){const t=createError("INVALID_ARCHIVE",{asarPath:r});return l.reject(t)}return l.resolve(!1!==n.stat(s))};const{existsSync:O}=t;t.existsSync=t=>{let e;try{e=splitPath(t)}catch{return!1}if(!e.isAsar)return O(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);return!!n&&!1!==n.stat(s)};const{access:g}=t;t.access=function(e,r,s){const n=splitPath(e);if(!n.isAsar)return g.apply(this,arguments);const{asarPath:i,filePath:a}=n;"function"==typeof r&&(s=r,r=t.constants.F_OK);const o=getOrCreateArchive(i);if(!o){const t=createError("INVALID_ARCHIVE",{asarPath:i});return void nextTick(s,[t])}const c=o.getFileInfo(a);if(!c){const t=createError("NOT_FOUND",{asarPath:i,filePath:a});return void nextTick(s,[t])}if(c.unpacked){const e=o.copyFileOut(a);return t.access(e,r,s)}if(o.stat(a))if(r&t.constants.W_OK){const t=createError("NO_ACCESS",{asarPath:i,filePath:a});nextTick(s,[t])}else nextTick(s);else{const t=createError("NOT_FOUND",{asarPath:i,filePath:a});nextTick(s,[t])}};const{access:m}=t.promises;t.promises.access=function(e,r){if(!splitPath(e).isAsar)return m.apply(this,arguments);return a.promisify(t.access)(e,r)};const{accessSync:S}=t;function fsReadFileAsar(e,r,n){const i=splitPath(e);if(i.isAsar){const{asarPath:e,filePath:a}=i;if("function"==typeof r)n=r,r={encoding:null};else if("string"==typeof r)r={encoding:r};else if(null==r)r={encoding:null};else if("object"!=typeof r)throw new TypeError("Bad arguments");const{encoding:o}=r,c=getOrCreateArchive(e);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:e});return void nextTick(n,[t])}const l=c.getFileInfo(a);if(!l){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}if(0===l.size)return void nextTick(n,[null,o?"":s.Buffer.alloc(0)]);if(l.unpacked){const e=c.copyFileOut(a);return t.readFile(e,r,n)}const f=s.Buffer.alloc(l.size),u=c.getFdAndValidateIntegrityLater();if(!(u>=0)){const t=createError("NOT_FOUND",{asarPath:e,filePath:a});return void nextTick(n,[t])}logASARAccess(e,a,l.offset),t.read(u,f,0,l.size,l.offset,(t=>{validateBufferIntegrity(f,l.integrity),n(t,o?f.toString(o):f)}))}}t.accessSync=function(e,r){const s=splitPath(e);if(!s.isAsar)return S.apply(this,arguments);const{asarPath:n,filePath:i}=s;null==r&&(r=t.constants.F_OK);const a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(o.unpacked){const e=a.copyFileOut(i);return t.accessSync(e,r)}if(!a.stat(i))throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(r&t.constants.W_OK)throw createError("NO_ACCESS",{asarPath:n,filePath:i})};const{readFile:D}=t;t.readFile=function(t,e,r){return splitPath(t).isAsar?fsReadFileAsar(t,e,r):D.apply(this,arguments)};const{readFile:R}=t.promises;function readFileFromArchiveSync(e,r){const{asarPath:n,filePath:i}=e,a=getOrCreateArchive(n);if(!a)throw createError("INVALID_ARCHIVE",{asarPath:n});const o=a.getFileInfo(i);if(!o)throw createError("NOT_FOUND",{asarPath:n,filePath:i});if(0===o.size)return r?"":s.Buffer.alloc(0);if(o.unpacked){const e=a.copyFileOut(i);return t.readFileSync(e,r)}if(r){if("string"==typeof r)r={encoding:r};else if("object"!=typeof r)throw new TypeError("Bad arguments")}else r={encoding:null};const{encoding:c}=r,l=s.Buffer.alloc(o.size),f=a.getFdAndValidateIntegrityLater();if(!(f>=0))throw createError("NOT_FOUND",{asarPath:n,filePath:i});return logASARAccess(n,i,o.offset),t.readSync(f,l,0,o.size,o.offset),validateBufferIntegrity(l,o.integrity),c?l.toString(c):l}t.promises.readFile=function(t,e){if(!splitPath(t).isAsar)return R.apply(this,arguments);return a.promisify(fsReadFileAsar)(t,e)};const{readFileSync:T}=t;t.readFileSync=function(t,e){const r=splitPath(t);return r.isAsar?readFileFromArchiveSync(r,e):T.apply(this,arguments)};const processReaddirResult=t=>t.context.withFileTypes?function handleDirents({result:t,currentPath:e,context:r}){const s=t[0].length;for(let n=0;n<s;n++){const s=i.join(e,t[0][n]),a=splitPath(s);let o=t[1][n];if(a.isAsar){const t=getOrCreateArchive(a.asarPath);if(!t)return;const e=t.stat(a.filePath);if(!e)continue;o=e.type}const c=_(e,t[0][n],o),l=u("fs").internalModuleStat(s);r.readdirResults.push(c),(c.isDirectory()||1===l)&&r.pathsQueue.push(i.join(c.path,c.name))}}(t):function handleFilePaths({result:t,currentPath:e,context:r}){for(let s=0;s<t.length;s++){const n=i.join(e,t[s]),a=i.relative(r.basePath,n),o=u("fs").internalModuleStat(n);r.readdirResults.push(a),1===o&&r.pathsQueue.push(n)}}(t);const{readdir:E}=t;t.readdir=function(e,r,s){if(F(s="function"==typeof r?r:s,"callback"),r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return void function readdirRecursive(t,e,r){const s={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};let n=0;!function read(t){const e=new h.FSReqCallback;e.oncomplete=(e,i)=>{e?r(e):void 0!==i?(processReaddirResult({result:i,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)):r(null,s.readdirResults)};const a=splitPath(t);if(a.isAsar){let e;const{asarPath:o,filePath:c}=a,l=getOrCreateArchive(o);if(!l){const t=createError("INVALID_ARCHIVE",{asarPath:o});return void nextTick(r,[t])}if(e=l.readdir(c),!e){const t=createError("NOT_FOUND",{asarPath:o,filePath:c});return void nextTick(r,[t])}s.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))]),processReaddirResult({result:e,currentPath:t,context:s}),n<s.pathsQueue.length?read(s.pathsQueue[n++]):r(null,s.readdirResults)}else h.readdir(t,s.encoding,s.withFileTypes,e)}(s.pathsQueue[n++])}(e,r,s);const n=splitPath(e);if(!n.isAsar)return E.apply(this,arguments);const{asarPath:a,filePath:o}=n,c=getOrCreateArchive(a);if(!c){const t=createError("INVALID_ARCHIVE",{asarPath:a});return void nextTick(s,[t])}const l=c.readdir(o);if(l)if(r?.withFileTypes){const e=[];for(const r of l){const n=i.join(o,r),l=c.stat(n);if(!l){const t=createError("NOT_FOUND",{asarPath:a,filePath:n});return void nextTick(s,[t])}e.push(new t.Dirent(r,l.type))}nextTick(s,[null,e])}else nextTick(s,[null,l]);else{const t=createError("NOT_FOUND",{asarPath:a,filePath:o});nextTick(s,[t])}};const{readdir:k}=t.promises;t.promises.readdir=async function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return async function readdirRecursivePromises(t,e){const r=[],s=splitPath(t);let n=[];const a=Boolean(e?.withFileTypes);let o=[];if(s.isAsar){const e=getOrCreateArchive(s.asarPath);if(!e)return r;const n=e.readdir(s.filePath);if(!n)return r;o=n,a&&(o=[[...o],o.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else o=await h.readdir(i.toNamespacedPath(t),e.encoding,a,b);if(n=[[t,o]],a)for(;n.length>0;){const{0:t,1:s}=n.pop();for(const a of getDirents(t,s))if(r.push(a),a.isDirectory()){const r=i.join(t,a.name),s=splitPath(r);let o;if(s.isAsar){const t=getOrCreateArchive(s.asarPath);if(!t)continue;const e=t.readdir(s.filePath);if(!e)continue;o=[[...e],e.map((t=>u("fs").internalModuleStat(i.join(r,t))))]}else o=await h.readdir(r,e.encoding,!0,b);n.push([r,o])}}else for(;n.length>0;){const{0:s,1:a}=n.pop();for(const o of a){const a=i.join(s,o),c=u("fs").internalModuleStat(a);if(r.push(i.relative(t,a)),1===c){const t=splitPath(a);let s=[];if(t.isAsar){const e=getOrCreateArchive(t.asarPath);if(!e)return;const n=e.readdir(t.filePath);if(!n)return r;s=n}else s=await h.readdir(i.toNamespacedPath(a),e.encoding,!1,b);n.push([a,s])}}}return r}(e,r);const s=splitPath(e);if(!s.isAsar)return k(e,r);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return l.reject(createError("INVALID_ARCHIVE",{asarPath:n}));const c=o.readdir(a);if(!c)return l.reject(createError("NOT_FOUND",{asarPath:n,filePath:a}));if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return l.resolve(e)}return l.resolve(c)};const{readdirSync:V}=t;t.readdirSync=function(e,r){if(r=P(r),e=y(e),null!=r?.recursive&&N(r?.recursive,"options.recursive"),r?.recursive)return function readdirSyncRecursive(t,e){const r={withFileTypes:Boolean(e.withFileTypes),encoding:e.encoding,basePath:t,readdirResults:[],pathsQueue:[t]};function read(t){let e;const s=splitPath(t);if(s.isAsar){const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)return;if(e=o.readdir(a),!e)return;r.withFileTypes&&(e=[[...e],e.map((e=>u("fs").internalModuleStat(i.join(t,e))))])}else e=h.readdir(i.toNamespacedPath(t),r.encoding,r.withFileTypes);void 0!==e&&processReaddirResult({result:e,currentPath:t,context:r})}for(let t=0;t<r.pathsQueue.length;t++)read(r.pathsQueue[t]);return r.readdirResults}(e,r);const s=splitPath(e);if(!s.isAsar)return V.apply(this,arguments);const{asarPath:n,filePath:a}=s,o=getOrCreateArchive(n);if(!o)throw createError("INVALID_ARCHIVE",{asarPath:n});const c=o.readdir(a);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:a});if(r?.withFileTypes){const e=[];for(const r of c){const s=i.join(a,r),c=o.stat(s);if(!c)throw createError("NOT_FOUND",{asarPath:n,filePath:s});e.push(new t.Dirent(r,c.type))}return e}return c};u("modules").overrideReadFileSync((t=>{const e=splitPath(t);if(e.isAsar)try{return readFileFromArchiveSync(e,void 0)}catch{return!1}}));const{internalModuleStat:x}=h;u("fs").internalModuleStat=t=>{const e=splitPath(t);if(!e.isAsar)return x(t);const{asarPath:r,filePath:s}=e,n=getOrCreateArchive(r);if(!n)return-34;const i=n.stat(s);return i?i.type===w.kDirectory?1:0:-34};const{kUsePromises:b}=h;if("win32"===process.platform){const{mkdir:e}=t;t.mkdir=(t,r,s)=>{"function"==typeof r&&(s=r,r={});const n=splitPath(t);if(n.isAsar&&n.filePath.length>0){const t=createError("NOT_DIR");nextTick(s,[t])}else e(t,r,s)},t.promises.mkdir=a.promisify(t.mkdir);const{mkdirSync:r}=t;t.mkdirSync=function(t,e){const s=splitPath(t);if(s.isAsar&&s.filePath.length)throw createError("NOT_DIR");return r(t,e)}}function invokeWithNoAsar(t){return function(){const e=process.noAsar;process.noAsar=!0;try{return t.apply(this,arguments)}finally{process.noAsar=e}}}overrideAPI(t,"copyFile"),overrideAPISync(t,"copyFileSync"),overrideAPI(t,"open"),overrideAPISync(process,"dlopen",1),overrideAPISync(c._extensions,".node",1),overrideAPISync(t,"openSync");const overrideChildProcess=t=>{const{exec:e,execSync:r}=t;t.exec=invokeWithNoAsar(e),t.exec[a.promisify.custom]=A("exec",invokeWithNoAsar(e[a.promisify.custom])),t.execSync=invokeWithNoAsar(r),overrideAPI(t,"execFile"),overrideAPISync(t,"execFileSync")},C=new WeakSet;if(process.env.ELECTRON_EAGER_ASAR_HOOK_FOR_TESTING)overrideChildProcess(r("child_process"));else{const t=c._load;c._load=(e,...r)=>{const s=t(e,...r);if(("child_process"===e||"node:child_process"===e)&&!C.has(s)){C.add(s);overrideChildProcess(s)}return s}}}},buffer:t=>{t.exports=require("buffer")},child_process:t=>{t.exports=require("child_process")},crypto:t=>{t.exports=require("crypto")},fs:t=>{t.exports=require("fs")},module:t=>{t.exports=require("module")},os:t=>{t.exports=require("os")},path:t=>{t.exports=require("path")},util:t=>{t.exports=require("util")}},e={};function __webpack_require__(r){var s=e[r];if(void 0!==s)return s.exports;var n=e[r]={exports:{}};return t[r](n,n.exports,__webpack_require__),n.exports}var r={};(()=>{var t=r;Object.defineProperty(t,"__esModule",{value:!0});if((0,__webpack_require__("./lib/node/asar-fs-wrapper.ts").wrapFsWithAsar)(__webpack_require__("fs")),globalThis.blinkfetch){const t=["fetch","Response","FormData","Request","Headers","EventSource"];for(const e of t)globalThis[e]=globalThis[`blink${e}`]}const e=__webpack_require__("child_process"),s=e.fork;e.fork=(t,e,r)=>(null==e?e=[]:"object"!=typeof e||Array.isArray(e)||(r=e,e=[]),"string"!=typeof t||!Array.isArray(e)||"object"!=typeof r&&void 0!==r||((r=r??{}).env=Object.create(r.env||process.env),r.env.ELECTRON_RUN_AS_NODE="1",r.execPath||"darwin"!==process.platform||(r.execPath=process.helperExecPath)),s(t,e,r));const n=__webpack_require__("path"),i=__webpack_require__("module"),a=process.resourcesPath+n.sep,o=i._nodeModulePaths;i._nodeModulePaths=function(t){const e=o(t);return(n.resolve(t)+n.sep).startsWith(a)?e.filter((function(t){return t.startsWith(a)})):e}})()})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

Error: The specified module could not be found.
C:\Users\ygaba\source\repos\BPSR-Meter\node_modules\electron\dist\resources\build\Release\windivert.node
    at process.func [as dlopen] (node:electron/js2c/node_init:2:2617)
    at file:///C:/Users/ygaba/source/repos/BPSR-Meter/out/main/server.js:735:9
    at ModuleJob.run (node:internal/modules/esm/module_job:345:25)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:665:26)
    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:132:5) {
  code: 'ERR_DLOPEN_FAILED'
}

Node.js v22.20.0
[2025-10-25T01:47:08.895Z] SERVER PROCESS EXITED with code: 1, signal: null
[2025-10-25T01:47:08.895Z] SERVER PROCESS CLOSED with code: 1
[2025-10-25T01:47:18.558Z] ERROR: Server did not respond in time (10s timeout)
[2025-10-25T01:47:20.865Z] All windows closed
[2025-10-25T01:47:20.866Z] Closing application (not macOS)
[2025-10-25T01:47:20.866Z] App closing, cleaning up processes...
